#!/usr/bin/perl -w
use strict;
use warnings;
eval("use Data::Dumper");

############################################################
# global variables

my $APPNAME = 'tsv';
my $VERSION = "0.1.200126-dev";

my $STDIN = '/dev/stdin';
my $STDOUT = '/dev/stdout';

my $dispatcher = {
	"cat"         => \&do_cat,
	"align"       => \&do_align,
	"view"        => \&do_view,
	"column"      => \&do_column,
	"transpose"   => \&do_transpose,
	"select"      => \&do_select,
	"select-rows" => \&do_select_rows,
	"head"        => \&do_head,
	"tail"        => \&do_tail,
	"filter"      => \&do_filter,
	"cleanup"     => \&do_cleanup,
	"sort"        => \&do_tsv_sort,
	"merge"       => \&do_tsv_merge,
	"join"        => \&do_tsv_join,
	"summary"     => \&do_tsv_summary,
	"to-csv"      => \&do_to_csv,
	"to-excel"    => \&do_tsv_to_excel,
	"version"     => \&do_version,
};

my $verbose = 0;

#----------------------------------------------------------#
# main program starts from here

my ($cmd_prefix, $cmd) = ($APPNAME, basename($0));
die "Error: Unexpected command name '$cmd'" if $cmd !~ /^$APPNAME(-|$)/;
if ($cmd eq $APPNAME) {
	print_usage() unless @ARGV;
	$cmd = shift @ARGV;
	$cmd_prefix .= ' ';
} else {
	$cmd =~ s/^$APPNAME-//;
	$cmd_prefix .= '-';
}
do_install() if $cmd eq 'install';
do_test() if $cmd eq 'test';
print_usage() if $cmd eq 'help';
die "Error: Unknown command '$cmd'" unless exists $dispatcher->{$cmd};
exit $dispatcher->{$cmd}->($cmd, @ARGV);

############################################################
# global helper functions

sub basename { my $s = shift; $s =~ s/^.*[\/\\]//; return $s; }
sub dirname  { my $s = shift; $s =~ s/[^\/\\]*$//; return $s; }

############################################################
# args processing

sub fetch_arg
{
	my ($opts, $name) = @_;
	die "Error: Missing option name '$name'" if not exists $opts->{$name};
	return ${$opts->{$name}} // '';
}

sub parse_args
{
	my ($cmd, $args, $func_usage, $func_opts, $vars, $rest_args) = @_;
	my $i = 0;
	my $parse_dash = 1;
	while (my $arg = shift @{$args}) {
		if ($parse_dash and $arg =~ /^-.+/) {
			if ($arg eq '--') {
				$parse_dash = 0;
			} elsif ($arg eq '-h' or $arg eq '--help') {
				$func_usage->($cmd, $func_opts);
			} elsif ($arg eq '-v' or $arg eq '--verbose') {
				++$verbose;
			} elsif ($arg =~ /^-[^-].+/) {
				my $curr = substr($arg, 0, 2);
				if ($curr eq '-h' or $curr eq '-v') {
					unshift @{$args}, ($curr, '-' . substr($arg, 2));
				} else {
					die "Error: Unknown option '$curr'" unless exists $func_opts->{$curr};
					if (ref($func_opts->{$curr}) eq 'SCALAR') {
						unshift @{$args}, ($curr, substr($arg, 2));
					} else {
						unshift @{$args}, ($curr, '-' . substr($arg, 2));
					}
				}
			} else {
				die "Error: Unknown option '$arg'" unless exists $func_opts->{$arg};
				for (;;) {
					my $type = ref($func_opts->{$arg});
					if ($type eq 'CODE') {
						$func_opts->{$arg}->($arg, $args);
						last;
					} elsif ($type eq 'SCALAR') {
						die "Error: Missing option for '$arg'" if not @{$args};
						${$func_opts->{$arg}} = shift @{$args};
						last;
					} else {
						my $s = $func_opts->{$arg};
						die "Error: Option should not point to itself" if $s eq $arg; 
						die "Error: Unexpected value '$s'" if exists $func_opts->{$s};
						$arg = $s;
					}
				}
			}
		} else {
			if ($i < scalar(@{$vars})) {
				${$vars->[$i++]} = $arg;
			} elsif (defined $rest_args) {
				push @{$rest_args}, $arg;
			} else {
				die "Error: Unexpected parameter '$arg'";
			}
		}
	}
}

############################################################
# version & usages

sub get_version_string
{
	chomp(my $hashcode = `md5sum $0`);
	my $version_suffix = '';
	if ($hashcode ne '') {
		$version_suffix = " (" . substr($hashcode, 0, 7) . ")";
	}
	return "$VERSION$version_suffix";
}

sub print_usage
{
	print '
Program: Toolkits for TSV (TAB-Separated Values) File
Version: ' . get_version_string() . '
Author : Linlin Yan <yanlinlin82@gmail.com>
License: MIT 2019-2020

Usage: ' . $APPNAME . ' <command> [options]

Commands:
  - Viewing
      cat           show original content
      align         align columns
      view          view file content in pretty better format
      column        list column names
      transpose     matrix transpose

  - Selecting
      select        select columns
      select-rows   select rows
      head          select head n rows
      tail          select tail n rows
      filter        filter by conditions
      cleanup       remove empty rows or columns

  - Manipulating
      sort          sort by column(s)
      merge         merge multiple files
      join          join two tables by key column(s)
      summary       summary each column

  - Writing
      to-csv        write to CSV file
      to-excel      write to Excel (.xlsx) file

  - Others
      version       show program version

';
	exit 1;
}

sub print_usage_cat
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt>

Options:
   -o <FILE>     Output file, default: " . fetch_arg($opts, '-o') . "
   -s <CHAR>     Separate character, default: <TAB>
   -n            Show row numbers
   --no-header   Input file does not have header line

";
	exit 1;
}

sub print_usage_align
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt>

Options:
   -o <FILE>           Output file, default: " . fetch_arg($opts, '-o') . "
   -s <CHAR>           Separate character, default: <TAB>
   --no-header         Input file does not have header line
   --max-width <int>   Maximum column width for each column, default: " . fetch_arg($opts, '--max-width') . "
   --max-check <int>   Maximum checking lines for calculate column width, default: " . fetch_arg($opts, '--max-check') . "

";
	exit 1;
}

sub print_usage_view
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt>

Options:
   -o <FILE>     Output file, default: " . fetch_arg($opts, '-o') . "
   -s <CHAR>     Separate character, default: <TAB>
   --no-header   Input file does not have header line

";
	exit 1;
}

sub print_usage_column
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt>

Options:
   -o <FILE>     Output file, default: " . fetch_arg($opts, '-o') . "
   -s <CHAR>     Separate character, default: <TAB>
   --no-header   Input file does not have header line

";
	exit 1;
}

sub print_usage_transpose
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt>

Options:
   -o <FILE>     Output file, default: " . fetch_arg($opts, '-o') . "
   -s <CHAR>     Separate character, default: <TAB>
   --no-header   Input file does not have header line

";
	exit 1;
}

sub print_usage_select
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt> <columns>...

Options:
   -o <FILE>     Output file, default: " . fetch_arg($opts, '-o') . "
   -s <CHAR>     Separate character, default: <TAB>
   --no-header   Input file does not have header line

Notes:
  1. <columns> can be either numbers or names, separated by ',' or space.
     e.g.:  $cmd_prefix$cmd in.txt id,name age
            $cmd_prefix$cmd in.txt 1,4 8
            $cmd_prefix$cmd in.txt 1,age 9
  2. column numbers are 1-based integers.
  3. column range is specified as format '<start>-<end>', '<start>:<end>' or '<start>..<end>'.
     e.g.:  $cmd_prefix$cmd in.txt id..age
            $cmd_prefix$cmd in.txt 1-9
            $cmd_prefix$cmd in.txt -5
            $cmd_prefix$cmd in.txt 5-

";
	exit 1;
}

sub print_usage_select_rows
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt> <rows>...

Options:
   -o <FILE>     Output file, default: " . fetch_arg($opts, '-o') . "
   -s <CHAR>     Separate character, default: <TAB>
   --no-header   Input file does not have header line

Notes:
  1. <rows> can be either numbers or names, separated by ',' or space.
     e.g.:  $cmd_prefix$cmd in.txt 1,3-5 10
  2. row numbers are 1-based integers.

";
	exit 1;
}

sub print_usage_head
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt>

Options:
   -n <INT>      Show first n rows, default: " . fetch_arg($opts, '-n') . "
   -o <FILE>     Output file, default: " . fetch_arg($opts, '-o') . "
   -s <CHAR>     Separate character, default: <TAB>
   --no-header   Input file does not have header line

Note:
  1. if '-n <INT>' is leading with '-', it will print all but the last <INT> lines.
     e.g.:  $cmd_prefix in.txt -n-10  # remove last 10 lines.

";
	exit 1;
}

sub print_usage_tail
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt>

Options:
   -n <INT>      Show last n rows, default: " . fetch_arg($opts, '-n') . "
   -o <FILE>     Output file, default: " . fetch_arg($opts, '-o') . "
   -s <CHAR>     Separate character, default: <TAB>
   --no-header   Input file does not have header line

Note:
  1. if '-n <INT>' is leading with '-', it will print all but the first <INT> lines.
     e.g.:  $cmd_prefix in.txt -n-10  # remove first 10 lines.

";
	exit 1;
}

sub print_usage_filter
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt> <condition>...

Options:
   -o <FILE>     Output file, default: " . fetch_arg($opts, '-o') . "
   -s <CHAR>     Separate character, default: <TAB>
   --no-header   Input file does not have header line

Notes:
  1. <condition> can be logical expression.
     e.g.:  $cmd_prefix$cmd in.txt 'age>=18'
            $cmd_prefix$cmd in.txt 'age>=18' 'sex==\"male\"'

";
	exit 1;
}

sub print_usage_cleanup
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt>

Options:
   -o <FILE>     Output file, default: " . fetch_arg($opts, '-o') . "
   -s <CHAR>     Separate character, default: <TAB>
   --no-header   Input file does not have header line

";
	exit 1;
}

sub print_usage_to_csv
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt>

Options:
   -o <FILE>     Output file, default: " . fetch_arg($opts, '-o') . "
   -s <CHAR>     Separate character, default: <TAB>
   --no-header   Input file does not have header line

";
	exit 1;
}

############################################################
# data frame manipulating

sub tsv_fetch_row
{
	my $d = shift @_;
	$d->{current_row} = 0 unless exists $d->{current_row};
	if ($d->{current_row} <= $#{$d->{data}}) {
		return $d->{data}->[$d->{current_row}++];
	}
	return undef;
}

sub tsv_sort
{
	my ($d, $column_count) = @_;
	my $max_column_count = scalar(@{$d->{data}});
	$column_count = 1 if $column_count < 1;
	$column_count = $max_column_count if $column_count > $max_column_count;
	my $column = $d->{names}->[$column_count - 1];
	@{$d->{data}} = sort { ($a->{$column} // '') cmp ($b->{$column} // '') } @{$d->{data}};
}

sub prepare_join_header
{
	my ($tsv1, $tsv2, $column) = @_;
	my %h1 = map { $tsv1->{names}->[$_] => $_ } (0 .. $#{$tsv1->{names}});
	my %h2 = map { $tsv2->{names}->[$_] => $_ } (0 .. $#{$tsv2->{names}});
	die "Error: column '$column' does not exist in left table" unless exists $h1{$column};
	die "Error: column '$column' does not exist in right table" unless exists $h2{$column};
	my @header = ();
	push @header, { TSV => "left", name => $column, index => $column };
	for my $name (@{$tsv1->{names}}) {
		if ($name ne $column) {
			push @header, {
				TSV => "left",
				name => $name . (exists $h2{$name} ? ".x" : ''),
				index => $name
			};
		}
	}
	for my $name (@{$tsv2->{names}}) {
		if ($name ne $column) {
			push @header, {
				TSV => "right",
				name => $name . (exists $h1{$name} ? ".y" : ''),
				index => $name
			};
		}
	}
	return \@header;
}

sub prepare_join_hash
{
	my ($d, $column) = @_;
	my @values = ();
	my %hash = ();
	for my $i (0 .. $#{$d->{data}}) {
		my $item = $d->{data}->[$i];
		my $key = $item->{$column};
		if (not exists $hash{$key}) {
			push @values, $key;
			$hash{$key} = [ $i ];
		} else {
			push @{$hash{$key}}, $i;
		}
	}
	return { values => \@values, hash => \%hash };
}

sub join_merge_item
{
	my ($item1, $item2, $header) = @_;
	my %hash = ();
	for my $h (@{$header}) {
		my ($d, $name, $index) = map { $h->{$_} } ("TSV", "name", "index");
		if ($d eq "left") {
			$hash{$name} = $item1->{$index};
		} else {
			$hash{$name} = $item2->{$index};
		}
	}
	return \%hash;
}

sub join_tsv
{
	my ($tsv1, $tsv2, $column) = @_;
	my $header = prepare_join_header($tsv1, $tsv2, $column);
	my $h1 = prepare_join_hash($tsv1, $column);
	my $h2 = prepare_join_hash($tsv2, $column);
	my @data = ();
	for my $value (@{$h1->{values}}) {
		next if not exists $h2->{hash}->{$value};
		for my $i (@{$h1->{hash}->{$value}}) {
			for my $j (@{$h2->{hash}->{$value}}) {
				push @data, join_merge_item($tsv1->{data}->[$i], $tsv2->{data}->[$j], $header);
			}
		}
	}
	return {
		names => [ map { $_->{name} } @{$header} ],
		data => \@data
	};
}

sub is_numeric
{
	my $val = shift @_;
	return do { no warnings; $val eq ($val + 0) };
}

sub parse_cond_obj
{
	my ($s, $names) = @_;
	$s =~ s/(^\s*|\s*$)//g;
	if ($s =~ /^[0-9]/) {
		return (eval($s), 'number');
	} elsif ($s =~ /^["']/) {
		return (eval($s), 'string');
	} else {
		die "Error: No column '$s' found" if not exists $names->{$s};
		return ($s, 'var');
	}
}

sub build_filter
{
	my ($conditions, $names) = @_;
	my @filter = ();
	for my $cond (@{$conditions}) {
		die "Error: Invalid condition '$cond'" if $cond !~ /^(.+)(==|!=|<=?|>=?|=~|!~)(.+)$/;
		my ($a, $op, $b) = ($1, $2, $3);
		my ($a_type, $b_type);
		($a, $a_type) = parse_cond_obj($a, $names);
		($b, $b_type) = parse_cond_obj($b, $names);
		die "Error: No column is specified in condition '$cond'" if $a_type ne 'var' and $b_type ne 'var';
		push @filter, {
			a => { val => $a, type => $a_type },
			op => $op,
			b => { val => $b, type => $b_type }
		};
	}
	return \@filter;
}

sub check_filter_ok
{
	my ($item, $filter) = @_;
	for my $cond (@{$filter}) {
		my $op = $cond->{op};
		my ($a, $a_type) = ($cond->{a}->{val}, $cond->{a}->{type});
		$a = $item->{$a} if $a_type eq 'var';
		my ($b, $b_type) = ($cond->{b}->{val}, $cond->{b}->{type});
		$b = $item->{$b} if $b_type eq 'var';
		if ($op eq '=~') {
			return 0 unless ($a =~ $b);
		} elsif ($op eq '!~') {
			return 0 unless ($a !~ $b);
		} else {
			my $n;
			if ($a_type eq 'string' or $b_type eq 'string') {
				$n = ($a cmp $b);
			} else {
				$n = ($a <=> $b);
			}
			return 0 unless eval($n . $cond->{op} . '0');
		}
	}
	return 1;
}

sub get_unique_name
{
	my ($name, $hash) = @_;
	$name =~ s/(^\s*|\s*$)//g;
	while ($name eq '' or exists $hash->{$name}) {
		if ($name =~ /^(.*)_([0-9]*)$/) {
			$name = $1 . "_" . (($2 // 0) + 1);
		} else {
			$name .= "_1";
		}
	}
	$hash->{$name} = 1;
	return $name;
}

sub fetch_xlsx_row
{
	my ($sheet, $row) = @_;
	my @values = ();
	my %decode = ( amp => "&", lt => "<", gt => ">", "quot" => "\"", "nbsp" => " " );
	for my $col ($sheet->{MinCol} .. $sheet->{MaxCol}) {
		my $cell = $sheet->{Cells}[$row][$col];
		my $value = ((not defined $cell) ? '' : ($cell->{Val} // ''));
		$value =~ s{&([a-z]+);}{$decode{$1}//$1}gex;
		$value =~ s/[\t\n\r]/ /gm;
		push @values, $value;
	}
	return @values;
}

sub prepare_colnames
{
	my ($names, $hash) = @_;
	return map {
		my ($original_name, $name) = ($_, $_);
		$name = "_" . $name if $name =~ /^[0-9]/;
		$name = get_unique_name($name, $hash);
		#print STDERR "Note: Column '$original_name' renamed to '$name'\n" if $original_name ne $name;
		$name;
	} @{$names};
}

sub load_xlsx
{
	eval("use Spreadsheet::XLSX");
	die "Error: Perl module 'Spreadsheet::XLSX' should be installed!" if $@;

	my ($filename, $no_header) = @_;
	my %sheet_no = ();
	if ($filename =~ /^(.+):([0-9,]+)$/) {
		$filename = $1;
		%sheet_no = map { $_ => 1 } (split(",", $2));
	}
	$sheet_no{1} = 1 unless %sheet_no; # load only the first sheet by default

	my $excel = Spreadsheet::XLSX->new($filename);
	if (not defined $excel) {
		print STDERR "Error: Can not open Excel file '$filename'. " . $excel->error() . ".\n";
		exit 1;
	}

	my $counter = 0;
	my $d;
	for my $sheet (@{$excel->{Worksheet}}) {
		my @names = ();
		my %hash = ();
		my @data = ();
		if (exists $sheet_no{0} or exists $sheet_no{++$counter}) {
			for my $row ($sheet->{MinRow} .. $sheet->{MaxRow}) {
				my @values = fetch_xlsx_row($sheet, $row);
				if ($row == $sheet->{MinRow} and not $no_header) {
					@names = prepare_colnames(\@values, \%hash);
				} else {
					if ($#names < $#values) {
						push @names, map { get_unique_name('', \%hash) } (($#names + 1) .. $#values)
					}
					my %item = map { $names[$_] => $values[$_] // '' } (0 .. $#names);
					push @data, \%item;
				}
			}
		}
		my $tsv2 = { names => \@names, data => \@data };
		if (not defined $d) {
			$d = $tsv2;
		} else {
			$d = merge_tsv($d, $tsv2);
		}
	}
	return $d;
}

sub autofit_columns {
	my $worksheet = shift;
	my $col       = 0;
	for my $width (@{$worksheet->{__col_widths}}) {
		$worksheet->set_column($col, $col, $width) if $width;
		$col++;
	}
}

sub store_string_widths {

	my $worksheet = shift;
	my $col       = $_[1];
	my $token     = $_[2];

	# Ignore some tokens that we aren't interested in.
	return if not defined $token;       # Ignore undefs.
	return if $token eq '';             # Ignore blank cells.
	return if ref $token eq 'ARRAY';    # Ignore array refs.
	return if $token =~ /^=/;           # Ignore formula

	# Ignore numbers
	return if $token =~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/;

	# Ignore various internal and external hyperlinks. In a real scenario
	# you may wish to track the length of the optional strings used with
	# urls.
	return if $token =~ m{^[fh]tt?ps?://};
	return if $token =~ m{^mailto:};
	return if $token =~ m{^(?:in|ex)ternal:};

	# We store the string width as data in the Worksheet object. We use
	# a double underscore key name to avoid conflicts with future names.
	#
	my $old_width    = $worksheet->{__col_widths}->[$col];
	my $string_width = string_width($token);

	if (not defined $old_width or $string_width > $old_width) {
		# You may wish to set a minimum column width as follows.
		#return undef if $string_width < 10;

		$worksheet->{__col_widths}->[$col] = $string_width;
	}
	# Return control to write();
	return undef;
}

sub string_width {
	return 0.9 * length($_[0]) + 3;
}

sub open_file
{
	my $filename = shift @_;
	my ($mod, $con) = ("<", $filename);
	die "Error: '$filename' is a directory" if -d $filename;
	if    ($filename eq "-"     ) { $mod = "<";  $con = $STDIN; }
	elsif ($filename =~ /\.gz$/ ) { $mod = "-|"; $con = "zcat '$filename'"; }
	elsif ($filename =~ /\.bz2$/) { $mod = "-|"; $con = "bzcat '$filename'"; }
	elsif ($filename =~ /\.zip$/) { $mod = "-|"; $con = "unzip -p '$filename'"; }
	open my $fh, $mod, $con or die "Error: Can not open file '$filename'";
	return $fh;
}

sub close_file
{
	my $fh = shift @_;
	close $fh;
}

sub load_bed
{
	# Spec: https://genome.ucsc.edu/FAQ/FAQformat.html#format1
	#       https://genome.ucsc.edu/FAQ/FAQformat.html#format1.7
	my $filename = shift @_;
	my $fh = open_file($filename);
	my @names = ("chrom", "chromStart", "chromEnd", "name", "score", "strand",
		"thickStart", "thickEnd", "itemRgb", "blockCount", "blockSizes", "blockStarts");
	my @names2 = (@names[0..2], "id", "desc", @names[3..$#names]);
	my @data = ();
	my $max_column_count = 0;
	my $has_bed_detail = 0;
	my $is_current_bed_detail = 0;
	while (my $line = <$fh>) {
		chomp $line;
		if ($line =~ /^track name=/) {
			if ($line =~ /type=bedDetail/) {
				$has_bed_detail = 1;
				$is_current_bed_detail = 1;
			} else {
				$is_current_bed_detail = 0;
			}
		} else {
			my @values = split("\t", $line, -1);
			die "Error: Unexpected column count" if scalar(@values) > ($is_current_bed_detail ? scalar(@names2) : scalar(@names));
			$max_column_count = scalar(@values) if $max_column_count < scalar(@values);
			my %item = map { ($is_current_bed_detail ? $names2[$_] : $names[$_]) => ($values[$_] // '') } (0 .. $#values);
			push @data, \%item;
		}
	}
	close_file($fh);
	if ($has_bed_detail) {
		@names2 = @names2[0 .. ($max_column_count - 1)];
		return { names => \@names2, data => \@data };
	} else {
		@names = @names[0 .. ($max_column_count - 1)];
		return { names => \@names, data => \@data };
	}
}

sub load_psl
{
	# Spec: https://genome.ucsc.edu/FAQ/FAQformat.html#format2
	my $filename = shift @_;
	my $fh = open_file($filename);
	my @names = ("matches", "misMatches", "repMatches", "nCount",
		"qNumInsert", "qBaseInsert", "tNumInsert", "tBaseInsert", "strand",
		"qName", "qSize", "qStart", "qEnd", "tName", "tSize", "tStart", "tEnd",
		"blockCount", "blockSizes", "qStarts", "tStarts");
	my @data = ();
	my $head_skipped = 1;
	while (my $line = <$fh>) {
		chomp $line;
		if ($fh->input_line_number == 1 and $line =~ /^psLayout/) {
			$head_skipped = 0;
		} elsif (not $head_skipped) {
			$head_skipped = 1 if $line =~ /^[-][-]*$/;
		} else {
			my @values = split("\t", $line, -1);
			die "Error: Unexpected column count" if $#values != $#names;
			my %item = map { $names[$_] => ($values[$_] // '') } (0 .. $#values);
			push @data, \%item;
		}
	}
	close_file($fh);
	return { names => \@names, data => \@data };
}

sub is_valid_xslx_ref
{
	my $filename = shift;
	if ($filename =~ /^(.*\.xlsx)(|:([0-9,]+))$/) {
		if (-e $1) {
			return 1;
		}
	}
	return 0;
}

sub load_tsv
{
	my ($filename, $no_header, $sep) = @_;
	my @names = ();
	my @data = ();
	die "Error: Input file '$filename' does not exist" unless -e $filename or is_valid_xslx_ref($filename);
	my ($mod, $con) = ("<", $filename);
	if (not defined $sep) {
		$sep = "\t";
		$sep = "," if $filename =~ /\.csv(|\.gz|\.bz2)$/;
	}
	if (is_valid_xslx_ref($filename)) { return load_xlsx($filename, $no_header); }
	if ($filename =~ /\.bed(|\.gz|\.bz2)$/) { return load_bed($filename); }
	if ($filename =~ /\.psl(|\.gz|\.bz2)$/) { return load_psl($filename); }
	my $fh = open_file($filename);
	my %hash = ();
	while (my $line = <$fh>) {
		chomp $line;
		if ($fh->input_line_number == 1 and not $no_header) {
			@names = split($sep, $line, -1);
			@names = prepare_colnames(\@names, \%hash);
		} else {
			my @values = split($sep, $line, -1);
			if ($#names < $#values) {
				push @names, map { get_unique_name('', \%hash) } (($#names + 1) .. $#values)
			}
			my %item = map { $names[$_] => ($values[$_] // '') } (0 .. $#names);
			push @data, \%item;
		}
	}
	close_file($fh);
	return { names => \@names, data => \@data };
}

sub has_na
{
	my ($item, $names) = @_;
	for my $name (@{$names}) {
		return 1 unless ($item->{$name} // '');
	}
	return 0;
}

sub write_tsv
{
	my ($d, $out_file, $opts) = @_;
	my $sep = $opts->{sep} // "\t";
	my $no_header = $opts->{no_header} // 0;
	my $col_index = $opts->{col_index};
	my $show_row_numbers = $opts->{show_row_numbers} // 0;
	my @names;
	if (not exists $opts->{col_index}) {
		@names = @{$d->{names}};
	} else {
		@names = map { $d->{names}->[$_ - 1] } @{$opts->{col_index}};
	}
	open my $fh, ">", $out_file or die "Error: Can not write to file '$out_file'";
	print $fh "\t" if $show_row_numbers;
	print $fh join($sep, @names), "\n" unless $no_header;
	if (exists $opts->{row_index}) {
		for my $r (@{$opts->{row_index}}) {
			my ($a, $b) = ($r->{start}, $r->{end});
			my $delta = ($a <= $b ? 1 : -1);
			for (my $i = $a; $i != $b + $delta; $i += $delta) {
				print $fh join($sep, map { $d->{data}->[$i - 1]->{$_} // '' } @names), "\n";
			}
		}
	} else {
		my $row_number = 0;
		while (my $item = tsv_fetch_row($d)) {
			++$row_number;
			next if exists $opts->{filter} and not check_filter_ok($item, $opts->{filter});
			next if exists $opts->{remove_na} and has_na($item, \@names);
			print $fh $row_number, "\t" if $show_row_numbers;
			print $fh join($sep, map { $item->{$_} // '' } (@names)), "\n";
		}
	}
	close $fh;
}

sub align_text
{
	my ($s, $w) = @_;
	$s = '' unless defined $s;
	if ($w > 0) {
		my $tw = get_text_width($s);
		if ($tw < $w) {
			$s .= (' ' x ($w - $tw));
		} elsif ($tw > $w) {
			$s = trim_text_at_width($s, $w, "...");
		}
	}
	return $s;
}

sub merge_tsv
{
	my ($a, $b) = @_;
	my @names = @{$a->{names}};
	my %hash = map { $_ => 1 } @names;
	for my $name (@{$b->{names}}) {
		push @names, $name unless exists $hash{$name};
		$hash{$name} = 1;
	}
	return { names => \@names, data => [ @{$a->{data}}, @{$b->{data}} ] };
}

sub skip_characters_in_range
{
	my ($s, $offset, $i, $lower, $upper) = @_;
	my $c;
	for (;;) {
		$c = ord(substr($s, $offset + $i, 1));
		last unless $c >= $lower and $c <= $upper;
		++$i;
	}
	return ($i, $c);
}

sub get_character_width
{
	my ($s, $offset) = @_;
	my $c = ord(substr($s, $offset, 1));
	my ($byte_count, $width);
	if ($c == 0x1B) {  # ANSI escape code
		my $c1 = ord(substr($s, $offset + 1, 1));
		if ($c1 == ord('[')) {  # Control Sequence Introducer
			my $i = 2;
			($i, $c1) = skip_characters_in_range($s, $offset, $i, 0x30, 0x3F);
			($i, $c1) = skip_characters_in_range($s, $offset, $i, 0x20, 0x2F);
			die "Unexpected CSI character '" . sprintf("%02X", $c1) . "' at byte offset '" . ($offset + $i) . "' of '$s'!" unless $c1 >= 0x40 and $c1 <= 0x7E;
			$byte_count = $i + 1;
			$width = 0;
		} else {
			die "Unexpected ANSI escape code '" . sprintf("%02X", $c1) . "' at byte offset '$offset' of '$s'!" unless $c1 >= 0x40 and $c1 <= 0x5F;
			$byte_count = 2;
			$width = 0;
		}
	} elsif ($c <= 0x7F) {  # U+0000 ~ U+007F: 0XXXXXXX
		$byte_count = 1;
		$width = 1;
	} elsif ($c <= 0xE0) {  # U+0080 ~ U+07FF: 110XXXXX 10XXXXXX
		$byte_count = 2;
		$width = 2;
	} elsif ($c <= 0xF0) {  # U+0800 ~ U+FFFF: 1110XXXX 10XXXXXX 10XXXXXX
		my ($c1, $c2) = map { ord(substr($s, $offset + $_, 1)) } (1, 2);
		$byte_count = 3;
		$width = (($c == 0xE2 and ($c1 >= 0x84 and $c1 <= 0xB9) and ($c2 >= 0x80 and $c2 <= 0xBF)) ? 1 : 2);
	} elsif ($c <= 0xF8) {  # U+10000 ~ U+1FFFFF: 11110XXXX 10XXXXXX 10XXXXXX 10XXXXXX
		$byte_count = 4;
		$width = 2;
	} elsif ($c <= 0xFC) {  # U+200000 ~ U+3FFFFFF: 11110XXXX 10XXXXXX 10XXXXXX 10XXXXXX 10XXXXXX
		$byte_count = 5;
		$width = 2;
	} elsif ($c <= 0xFE) {  # U+4000000 ~ U+7FFFFFFF: 11110XXXX 10XXXXXX 10XXXXXX 10XXXXXX 10XXXXXX 10XXXXXX
		$byte_count = 6;
		$width = 2;
	} else {
		die "Unexpected UTF8 character '" . sprintf("%02X", $c) . "' at byte offset '$offset' of '$s'!";
	}
	die "Truncated string at byte offset '$offset' of '$s'!" if $offset + $byte_count > length($s);
	return ($byte_count, $width);
}

sub get_text_width
{
	my $s = shift // '';
	my $width = 0;
	for (my $i = 0; $i < length($s);) {
		my ($byte_count, $w) = get_character_width($s, $i);
		$i += $byte_count;
		$width += $w;
	}
	return $width;
}

sub trim_text_at_width
{
	my ($s, $expected_width, $append_suffix) = @_;
	my $width_upper_limit = $expected_width - get_text_width($append_suffix);
	my ($i, $width) = (0, 0);
	for (; $i < length($s);) {
		my ($byte_count, $w) = get_character_width($s, $i);
		last if $width + $byte_count > $width_upper_limit;
		$i += $byte_count;
		$width += $w;
	}
	return substr($s, 0, $i) . $append_suffix . (" " x ($width_upper_limit - $width));
}

sub quantile
{
	my ($data, $prob) = @_;
	my $index = (scalar(@{$data}) + 1) * $prob - 1;
	my $base_value = $data->[int($index)];
	return $base_value + ($data->[int($index) + 1] - $base_value) * ($index - int($index));
}

sub mean
{
	my $data = shift @_;
	if (scalar(@{$data}) == 0) {
		return "NA";
	} else {
		my $sum = 0;
		for my $value (@{$data}) {
			$sum += $value;
		}
		return $sum / scalar(@{$data});
	}
}

sub calc_summary
{
	my ($data, $name, $summary_fields) = @_;
	my @values = sort { $a <=> $b } map { $_->{$name} } @{$data};
	return {
		$summary_fields->[0] => $values[0],              # "Min."
		$summary_fields->[1] => quantile(\@values, .25), # "1st Qu."
		$summary_fields->[2] => quantile(\@values, .5),  # "Median"
		$summary_fields->[3] => mean(\@values),          # "Mean"
		$summary_fields->[4] => quantile(\@values, .75), # "3rd Qu."
		$summary_fields->[5] => $values[$#values],       # "Max."
	};
}

sub write_align
{
	my ($d, $no_header, $out_file, $max_width, $max_check) = @_;
	my %width = map { $_ => ($no_header ? 0 : get_text_width($_)) } @{$d->{names}};
	my $counter = 0;
	for my $item (@{$d->{data}}) {
		for my $name (@{$d->{names}}) {
			if ($width{$name} < $max_width) {
				my $width = get_text_width($item->{$name});
				$width = $max_width if $width > $max_width;
				$width{$name} = $width if $width{$name} < $width;
			}
		}
		last if ++$counter >= $max_check;
	}
	open my $ofh, '>', $out_file or die "Error: Can not create file '$out_file'";
	if (not $no_header) {
		print $ofh join("  ", map { align_text($_, $width{$_}) } @{$d->{names}}), "\n";
	}
	for my $item (@{$d->{data}}) {
		print $ofh join("  ", map { align_text($item->{$_}, $width{$_}) } @{$d->{names}}), "\n";
	}
	close $ofh;
}

sub write_view
{
	my ($d, $out_file) = @_;
	open my $ofh, '>', $out_file or die "Error: Can not create file '$out_file'";
	my $max_name_width = length('column');
	my $names = $d->{names};
	my $id_width = get_text_width(scalar(@{$names}) - 1);
	my $max_id_width = ($id_width >= length('id') ? $id_width : length('id'));
	for my $name (@{$names}) {
		my $width = get_text_width($name);
		$max_name_width = $width if $max_name_width < $width;
	}
	my $row = 0;
	while (my $item = tsv_fetch_row($d)) {
		print $ofh "# row " . ++$row . "\n";
		print $ofh join("  ",
			align_text('id', $max_id_width),
			align_text('column', $max_name_width),
			'value'), "\n";
		my $column_id = 0;
		for my $name (@{$names}) {
			print $ofh join("  ",
				align_text(++$column_id, $max_id_width),
				align_text($name, $max_name_width),
				$item->{$name}), "\n";
		}
		print $ofh "\n";
	}
	close $ofh;
}

sub write_column
{
	my ($d, $out_file) = @_;
	my $column = {
		names => [ "number", "colname" ],
		data => [ map { {
				number => $_ + 1,
				colname => $d->{names}->[$_]
			} } (0 .. $#{$d->{names}}) ]
	};
	write_tsv($column, $out_file);
}

sub write_transpose
{
	my ($d, $out_file) = @_;
	my $res = {
		names => [ "colname", map { "row_" . ($_ + 1) } (0 .. $#{$d->{data}}) ],
		data => [ map {
				my $name = $_;
				{
					"colname" => $name,
					map { "row_" . ($_ + 1) => $d->{data}->[$_]->{$name} } (0 .. $#{$d->{data}})
				}
			} @{$d->{names}} ]
	};
	write_tsv($res, $out_file);
}

sub expand_row_index
{
	my ($x, $n) = @_;
	my @s = split(',', $x);
	if (scalar(@s) > 1) {
		return map { expand_row_index($_, $n) } @s;
	}
	if ($x =~ /^[0-9]+$/) {
		return ( { start => $x, end => $x } ) if $x >= 1 and $x <= $n;
		die "Error: Invalid row number '$x'! It should be between 1 and $n";
	} elsif ($x =~ /^(.*)(\-|:|\.\.)(.*)$/) {
		my ($a, $b) = ($1, $3);
		$a = 1 if $a eq '';
		$b = $n if $b eq '';
		return ( { start => $a, end => $b } ) if $a >= 1 and $a <= $n and $b >= 1 and $b <= $n;
		die "Error: Invalid row range '$x'! It should be between 1 and $n";
	} else {
		die "Error: Invalid row number '$x'!";
	}
}

sub expand_column_index
{
	my ($x, $dict, $columns, $maybe_range) = @_;
	my $n = scalar(@{$columns});
	return $dict->{$x} if exists $dict->{$x};
	my @s = split(',', $x);
	if (scalar(@s) > 1) {
		return map { expand_column_index($_, $dict, $columns, 1) } (@s);
	}
	if ($maybe_range and ($x =~ /^(.*)(\-|:|\.\.)(.*)$/)) {
		my ($a, $b) = ($1, $3);
		$a = 1 if $a eq '';
		$b = $n if $b eq '';
		$a = expand_column_index($a, $dict, $columns, 0);
		$b = expand_column_index($b, $dict, $columns, 0);
		if ($a <= $b) { return ($a .. $b); } else { return reverse ($b .. $a); }
	}
	if ($x =~ /^[0-9]+$/) {
		return $x if $x >= 1 and $x <= $n;
		die "Error: Invalid column number '$x'! It should be between 1 and $n";
	} else {
		die "Error: Invalid column name '$x'! Available colum names: ('" . join("', '", @{$columns}) . "')"
	}
}

############################################################
# commands

sub do_cat
{
	my ($cmd, @args) = @_;

	my ($in_file, $no_header, $show_row_numbers, $out_file, $sep) = ('', 0, 0, $STDOUT, "\t");
	my $opts = {
		'-o' => \$out_file,
		'-s' => \$sep,
		'-n' => sub { $show_row_numbers = 1; },
		'--no-header' => sub { $no_header = 1; },
	};
	parse_args($cmd, \@args, \&print_usage_cat, $opts, [ \$in_file ]);

	if ($in_file eq '') {
		print_usage_cat($cmd, $opts) if -t STDIN;
		$in_file = $STDIN;
	}

	my $d = load_tsv($in_file, $no_header, $sep);
	write_tsv($d, $out_file, { show_row_numbers => $show_row_numbers });
	exit 0;
}

sub do_align
{
	my ($cmd, @args) = @_;

	my ($in_file, $no_header, $out_file, $sep) = ('', 0, $STDOUT, "\t");
	my $max_width = 100;
	my $max_check = 1000;
	my $opts = {
		'-o' => \$out_file,
		'-s' => \$sep,
		'--no-header' => sub { $no_header = 1; },
		'--max-width' => \$max_width,
		'--max-check' => \$max_check,
	};
	parse_args($cmd, \@args, \&print_usage_align, $opts, [ \$in_file ]);

	if ($in_file eq '') {
		print_usage_align($cmd, $opts) if -t STDIN;
		$in_file = $STDIN;
	}

	my $d = load_tsv($in_file, $no_header, $sep);
	write_align($d, $no_header, $out_file, $max_width, $max_check);
	exit 0;
}

sub do_view
{
	my ($cmd, @args) = @_;

	my ($in_file, $no_header, $out_file, $sep) = ('', 0, $STDOUT, "\t");
	my $opts = {
		'-o' => \$out_file,
		'-s' => \$sep,
		'--no-header' => sub { $no_header = 1; },
	};
	parse_args($cmd, \@args, \&print_usage_view, $opts, [ \$in_file ]);

	if ($in_file eq '') {
		print_usage_view($cmd, $opts) if -t STDIN;
		$in_file = $STDIN;
	}

	my $d = load_tsv($in_file, $no_header, $sep);
	write_view($d, $out_file);
	exit 0;
}

sub do_column
{
	my ($cmd, @args) = @_;

	my ($in_file, $no_header, $out_file, $sep) = ('', 0, $STDOUT, "\t");
	my $opts = {
		'-o' => \$out_file,
		'-s' => \$sep,
		'--no-header' => sub { $no_header = 1; },
	};
	parse_args($cmd, \@args, \&print_usage_column, $opts, [ \$in_file ]);

	if ($in_file eq '') {
		print_usage_column($cmd, $opts) if -t STDIN;
		$in_file = $STDIN;
	}

	my $d = load_tsv($in_file, $no_header, $sep);
	write_column($d, $out_file);
	exit 0;
}

sub do_transpose
{
	my ($cmd, @args) = @_;

	my ($in_file, $no_header, $out_file, $sep) = ('', 0, $STDOUT, "\t");
	my $opts = {
		'-o' => \$out_file,
		'-s' => \$sep,
		'--no-header' => sub { $no_header = 1; },
	};
	parse_args($cmd, \@args, \&print_usage_transpose, $opts, [ \$in_file ]);

	if ($in_file eq '') {
		print_usage_transpose($cmd, $opts) if -t STDIN;
		$in_file = $STDIN;
	}

	my $d = load_tsv($in_file, $no_header, $sep);
	write_transpose($d, $out_file);
	exit 0;
}

sub do_select
{
	my ($cmd, @args) = @_;

	my ($in_file, $no_header, $out_file, $sep) = ('', 0, $STDOUT, "\t");
	my $opts = {
		'-o' => \$out_file,
		'-s' => \$sep,
		'--no-header' => sub { $no_header = 1; },
	};
	my @columns = ();
	parse_args($cmd, \@args, \&print_usage_select, $opts, [ \$in_file ], \@columns);

	if ($in_file ne '' and not -e $in_file and not -t STDIN) {
		unshift @columns, $in_file;
		$in_file = $STDIN;
	}
	print_usage_select($cmd, $opts) if $in_file eq '' or not @columns;

	my $d = load_tsv($in_file, $no_header, $sep);
	my %dict = map { $_ => 1 } @{$d->{names}};
	my @col_index = map { expand_column_index($_, \%dict, $d->{names}, 1) } (@columns);
	write_tsv($d, $out_file, { no_header => $no_header, col_index => \@col_index });
	exit 0;
}

sub do_select_rows
{
	my ($cmd, @args) = @_;

	my ($in_file, $no_header, $out_file, $sep) = ('', 0, $STDOUT, "\t");
	my $opts = {
		'-o' => \$out_file,
		'-s' => \$sep,
		'--no-header' => sub { $no_header = 1; },
	};
	my @rows = ();
	parse_args($cmd, \@args, \&print_usage_select_rows, $opts, [ \$in_file ], \@rows);

	if ($in_file ne '' and not -e $in_file and not -t STDIN) {
		unshift @rows, $in_file;
		$in_file = $STDIN;
	}
	print_usage_select_rows($cmd, $opts) if $in_file eq '' or not @rows;

	my $d = load_tsv($in_file, $no_header, $sep);
	my $n = scalar(@{$d->{data}});
	my @row_index = map { expand_row_index($_, $n) } (@rows);
	write_tsv($d, $out_file, { no_header => $no_header, row_index => \@row_index });
	exit 0;
}

sub do_head
{
	my ($cmd, @args) = @_;

	my ($in_file, $row_count, $no_header, $out_file, $sep) = ('', 10, 0, $STDOUT, "\t");
	my $opts = {
		'-n' => \$row_count,
		'-o' => \$out_file,
		'-s' => \$sep,
		'--no-header' => sub { $no_header = 1; },
	};
	parse_args($cmd, \@args, \&print_usage_head, $opts, [ \$in_file ]);

	if ($in_file eq '') {
		print_usage_head($cmd, $opts) if -t STDIN;
		$in_file = $STDIN;
	}

	my $d = load_tsv($in_file, $no_header, $sep);
	die "Error: Invalid value '$row_count' for '-n'" if $row_count !~ /^[-+]?[0-9]+$/;
	my $n = scalar(@{$d->{data}});
	my @row_index = ();
	if ($row_count > 0) {
		$row_count = $n if $row_count > $n;
		push @row_index, { start => 1, end => $row_count };
	} elsif ($row_count < 0) {
		$row_count = -$n if $row_count < -$n;
		push @row_index, { start => 1, end => $n + $row_count } if $row_count > -$n;
	}
	write_tsv($d, $out_file, { no_header => $no_header, row_index => \@row_index });
	exit 0;
}

sub do_tail
{
	my ($cmd, @args) = @_;

	my ($in_file, $row_count, $no_header, $out_file, $sep) = ('', 10, 0, $STDOUT, "\t");
	my $opts = {
		'-n' => \$row_count,
		'-o' => \$out_file,
		'-s' => \$sep,
		'--no-header' => sub { $no_header = 1; },
	};
	parse_args($cmd, \@args, \&print_usage_head, $opts, [ \$in_file ]);

	if ($in_file eq '') {
		print_usage_head($cmd, $opts) if -t STDIN;
		$in_file = $STDIN;
	}

	my $d = load_tsv($in_file, $no_header, $sep);
	die "Error: Invalid value '$row_count' for '-n'" if $row_count !~ /^[-+]?[0-9]+$/;
	my $n = scalar(@{$d->{data}});
	my @row_index = ();
	if ($row_count > 0) {
		$row_count = $n if $row_count > $n;
		push @row_index, { start => $n - $row_count + 1, end => $n };
	} elsif ($row_count < 0) {
		$row_count = -$n if $row_count < -$n;
		push @row_index, { start => 1 - $row_count, end => $n } if $row_count > -$n;
	}
	write_tsv($d, $out_file, { no_header => $no_header, row_index => \@row_index });
	exit 0;
}

sub do_filter
{
	my ($cmd, @args) = @_;

	my ($in_file, $no_header, $out_file, $sep) = ('', 0, $STDOUT, "\t");
	my $opts = {
		'-o' => \$out_file,
		'-s' => \$sep,
		'--no-header' => sub { $no_header = 1; },
	};
	my @conditions = ();
	parse_args($cmd, \@args, \&print_usage_filter, $opts, [ \$in_file ], \@conditions);

	if ($in_file ne '' and not -e $in_file and not -t STDIN) {
		unshift @conditions, $in_file;
		$in_file = $STDIN;
	}
	print_usage_filter($cmd, $opts) if $in_file eq '' or not @conditions;

	my $d = load_tsv($in_file, $no_header, $sep);
	my %names = map { $_ => 1 } @{$d->{names}};
	my $filter = build_filter(\@conditions, \%names);
	write_tsv($d, $out_file, { filter => $filter });
	exit 0;
}

sub do_cleanup
{
	my ($cmd, @args) = @_;

	my ($in_file, $no_header, $out_file, $sep) = ('', 0, $STDOUT, "\t");
	my $opts = {
		'--no-header' => sub { $no_header = 1; },
		'-s' => \$sep,
		'-o' => \$out_file
	};
	parse_args($cmd, \@args, \&print_usage_cleanup, $opts, [ \$in_file ]);

	if ($in_file eq '') {
		print_usage_cleanup($cmd, $opts) if -t STDIN;
		$in_file = $STDIN;
	}

	my $d = load_tsv($in_file, $no_header, $sep);
	my @col_index = ();
	for my $i (0 .. $#{$d->{names}}) {
		my $name = $d->{names}->[$i];
		my $has_data = 0;
		for my $item (@{$d->{data}}) {
			if ($item->{$name} // '') { $has_data = 1; last; }
		}
		push @col_index, $i + 1 if $has_data;
	}
	write_tsv($d, $STDOUT, { col_index => \@col_index, remove_na => 1 });
	exit 0;
}

sub do_tsv_sort
{
	my ($in_file, $column_count);
	if (scalar(@ARGV) >= 2) {
		($in_file, $column_count) = @ARGV;
	} elsif (scalar(@ARGV) == 1) {
		if (not -t STDIN) {
			($in_file, $column_count) = ($STDIN, $ARGV[0]);
		} else {
			($in_file, $column_count) = ($ARGV[0], 1);
		}
	} else {
		if (-t STDIN) {
			print "Usage: $cmd_prefix$cmd <in.txt> [column_count]\n";
			exit 1;
		}
		($in_file, $column_count) = ($STDIN, 1);
	}
	my $d = load_tsv($in_file);
	tsv_sort($d, $column_count);
	write_tsv($d, $STDOUT);
	exit 0;
}

sub do_tsv_merge
{
	if (scalar @ARGV < 2) {
		print "Usage: $cmd_prefix$cmd <in_1.txt> <in_2.txt>...\n";
		print "       $cmd_prefix$cmd -f <file-list.txt>\n";
		exit 1;
	}
	my @in_files;
	if ($ARGV[0] ne "-f") {
		@in_files = @ARGV;
	} else {
		shift @ARGV;
		die "Error: Missing parameter after '-f'" unless @ARGV;
		open my $fh, "<", ($ARGV[0] eq "-" ? $STDIN : $ARGV[0]) or die "Error: Can not open file '$ARGV[0]'";
		@in_files = map { chomp; $_ } <$fh>;
		close $fh;
	}
	my $d = load_tsv(shift @in_files);
	while (my $filename = shift @in_files) {
		$d = merge_tsv($d, load_tsv($filename));
	}
	write_tsv($d, $STDOUT);
	exit 0;
}

sub do_tsv_join
{
	my ($left_file, $right_file, $column);
	if (scalar(@ARGV) >= 3) {
		($left_file, $right_file, $column) = @ARGV;
	} elsif (scalar(@ARGV) == 2 and not -t STDIN) {
		($left_file, $right_file, $column) = ($STDIN, @ARGV);
	} else {
		print "Usage: $cmd_prefix$cmd <in-left.txt> <in-right.txt> <column>\n";
		exit 1;
	}
	my $tsv1 = load_tsv($left_file);
	my $tsv2 = load_tsv($right_file);
	my $d = join_tsv($tsv1, $tsv2, $column);
	write_tsv($d, $STDOUT);
	exit 0;
}

sub do_tsv_summary
{
	my $in_file;
	if (scalar(@ARGV) >= 1) {
		$in_file = shift @ARGV;
	} elsif (not -t STDIN) {
		$in_file = $STDIN;
	} else {
		print "Usage: $cmd_prefix$cmd <in.txt>\n";
		exit 1;
	}
	my $d = load_tsv($in_file);
	my %results = ();
	my @summary_fields = ("Min.", "1st Qu.", "Median", "Mean", "3rd Qu.", "Max.");
	for my $name (@{$d->{names}}) {
		$results{$name} = calc_summary($d->{data}, $name, \@summary_fields);
	}
	my $summary = {
		names => [ "stat_name", @{$d->{names}} ],
		data => [ ]
	};
	for my $stat_name (@summary_fields) {
		my %item = ( stat_name => $stat_name );
		for my $name (@{$d->{names}}) {
			$item{$name} = $results{$name}->{$stat_name};
		}
		push @{$summary->{data}}, \%item;
	}
	write_tsv($summary, $STDOUT);
	exit 0;
}

sub do_to_csv
{
	my ($cmd, @args) = @_;

	my ($in_file, $no_header, $out_file, $sep) = ('', 0, $STDOUT, "\t");
	my $opts = {
		'-o' => \$out_file,
		'-s' => \$sep,
		'--no-header' => sub { $no_header = 1; },
	};
	parse_args($cmd, \@args, \&print_usage_to_csv, $opts, [ \$in_file ]);

	if ($in_file eq '') {
		print_usage_to_csv($cmd, $opts) if -t STDIN;
		$in_file = $STDIN;
	}

	my $d = load_tsv($in_file, $no_header, $sep);
	write_tsv($d, $out_file, { sep => ',' });
	exit 0;
}

sub do_tsv_to_excel
{
	eval("use Encode");
	die "Error: Perl module 'Encode' should be installed!" if $@;
	eval("use Excel::Writer::XLSX");
	die "Error: Perl module 'Excel::Writer::XLSX' should be installed!" if $@;

	if (scalar @ARGV < 2) {
		print "Usage: $cmd_prefix$cmd <out.xlsx> <in.tsv>...\n";
		exit 1;
	}
	my $out_xlsx = shift @ARGV;
	if (-e $out_xlsx and $out_xlsx !~ /\.xlsx$/) {
		print "Warning: output Excel filename should be the first parameter!\n";
		exit 1;
	}
	my $excel = Excel::Writer::XLSX->new($out_xlsx);

	for my $arg (@ARGV) {
		my $in_tsv = $arg;
		my $name;
		if (not -e $in_tsv and $arg =~ /^(.+)=(.+)$/) {
			($name, $in_tsv) = ($1, $2);
		} else {
			$name = $in_tsv;
			$name =~ s/^.*\///g;
			$name =~ s/\.[^\.]+$//;
		}
		my $worksheet = $excel->add_worksheet(decode("utf8", $name));
		$worksheet->add_write_handler(qr[\w], \&store_string_widths);

		my $d = load_tsv($in_tsv);

		my $format = $excel->add_format( bold => 1, bg_color => '#dddddd', align => 'center', border => 1 );
		my ($row, $col) = (0, 0);
		for my $name (@{$d->{names}}) {
			$worksheet->write($row, $col++, decode("utf8", $name), $format);
		}

		$worksheet->freeze_panes(1, 0); # Freeze the first row
		$format = $excel->add_format( border => 1 );
		for my $item (@{$d->{data}}) {
			$row++;
			$col = 0;
			for my $name (@{$d->{names}}) {
				$worksheet->write($row, $col++, decode("utf8", $item->{$name}), $format);
			}
		}
		autofit_columns($worksheet);
	}
}

sub do_version
{
	print get_version_string(), "\n";
	exit 0;
}

sub do_install
{
	my $dir = dirname($0);
	for my $cmd (sort keys %{$dispatcher}) {
		my $name = $dir . $APPNAME . '-' . $cmd;
		unless (-e $name) {
			symlink $APPNAME, $name or die "Error: Can not create symbolic link '$name'!";
			print STDERR "Symbolic link '$name' created.\n";
		}
	}
	print STDERR "All symbolic links are created.\n";
	eval("use Excel::Writer::XLSX");
	print STDERR "Warning: Perl module 'Excel::Writer::XLSX' is required for writing Excel files\n" if $@;
	eval("use Spreadsheet::XLSX");
	print STDERR "Warning: Perl module 'Spreadsheet::XLSX' is required for reading Excel files\n" if $@;
	exit 0;
}

sub do_test
{
	my ($total, $ok, $failed) = (0, 0, 0);
	chdir(dirname($0));
	foreach my $script (glob("test/*.sh")) {
		print STDERR "$script\n";
		open my $fh, "-|", $script or die "Error: Can not execute script '$script'!";
		while (my $line = <$fh>) {
			if ($line =~ /^OK/) {
				$total++;
				$ok++;
			} elsif ($line =~ /^Failed/) {
				$total++;
				$failed++;
			}
			print ". $line" if $verbose;
		}
		close $fh;
	}
	print STDERR "Total $total test(s), $ok passed and $failed failed.\n";
	exit 0;
}
