#!/usr/bin/perl -w
use strict;
use warnings;
BEGIN { eval 'use Data::Dumper' };

############################################################
# global variables

my $APPNAME = 'tsv';
my $VERSION = "0.2.200126-beta";

my $STDIN = '/dev/stdin';
my $STDOUT = '/dev/stdout';

my $dispatcher = {
	"cat"         => \&do_cat,
	"align"       => \&do_align,
	"view"        => \&do_view,
	"column"      => \&do_column,
	"dim"         => \&do_dim,
	"count"       => \&do_count,
	"select"      => \&do_select,
	"select-rows" => \&do_select_rows,
	"head"        => \&do_head,
	"tail"        => \&do_tail,
	"filter"      => \&do_filter,
	"cleanup"     => \&do_cleanup,
	"transpose"   => \&do_transpose,
	"sort"        => \&do_sort,
	"merge"       => \&do_merge,
	"join"        => \&do_join,
	"summary"     => \&do_summary,
	"to-csv"      => \&do_to_csv,
	"to-xlsx"     => \&do_to_xlsx,
	"version"     => \&do_version,
};

my $verbose = 0;

#----------------------------------------------------------#
# main program starts from here

my ($cmd_prefix, $cmd) = ($APPNAME, basename($0));
die "Error: Unexpected command name '$cmd'" if $cmd !~ /^$APPNAME(-|$)/;
if ($cmd eq $APPNAME) {
	print_usage() unless @ARGV;
	$cmd = shift @ARGV;
	$cmd_prefix .= ' ';
} else {
	$cmd =~ s/^$APPNAME-//;
	$cmd_prefix .= '-';
}
do_install() if $cmd eq 'install';
do_test() if $cmd eq 'test';
print_usage() if $cmd eq 'help';
die "Error: Unknown command '$cmd'" unless exists $dispatcher->{$cmd};
exit $dispatcher->{$cmd}->($cmd, @ARGV);

############################################################
# global helper functions

sub basename { my $s = shift; $s =~ s/^.*[\/\\]//; return $s; }
sub dirname  { my $s = shift; $s =~ s/[^\/\\]*$//; return $s; }

############################################################
# args processing

sub fetch_arg
{
	my ($opts, $name) = @_;
	die "Error: Missing option name '$name'" if not exists $opts->{$name};
	return ${$opts->{$name}} // '';
}

sub parse_args
{
	my ($cmd, $args, $func_usage, $func_opts, $vars, $rest_args) = @_;
	my $i = 0;
	my $parse_dash = 1;
	while (defined(my $arg = shift @{$args})) {
		if ($parse_dash and $arg =~ /^-.+/) {
			if ($arg eq '--') {
				$parse_dash = 0;
			} elsif ($arg eq '-h' or $arg eq '--help') {
				$func_usage->($cmd, $func_opts);
			} elsif ($arg eq '-v' or $arg eq '--verbose') {
				++$verbose;
			} elsif ($arg =~ /^-[^-].+/) {
				my $curr = substr($arg, 0, 2);
				if ($curr eq '-h' or $curr eq '-v') {
					unshift @{$args}, ($curr, '-' . substr($arg, 2));
				} else {
					die "Error: Unknown option '$curr'" unless exists $func_opts->{$curr};
					if (ref($func_opts->{$curr}) eq 'SCALAR') {
						unshift @{$args}, ($curr, substr($arg, 2));
					} else {
						unshift @{$args}, ($curr, '-' . substr($arg, 2));
					}
				}
			} else {
				die "Error: Unknown option '$arg'" unless exists $func_opts->{$arg};
				for (;;) {
					my $type = ref($func_opts->{$arg});
					if ($type eq 'CODE') {
						$func_opts->{$arg}->($arg, $args);
						last;
					} elsif ($type eq 'SCALAR') {
						die "Error: Missing option for '$arg'" if not @{$args};
						${$func_opts->{$arg}} = shift @{$args};
						last;
					} else {
						my $s = $func_opts->{$arg};
						die "Error: Option should not point to itself" if $s eq $arg; 
						die "Error: Unexpected value '$s'" if exists $func_opts->{$s};
						$arg = $s;
					}
				}
			}
		} else {
			if ($i < scalar(@{$vars})) {
				${$vars->[$i++]} = $arg;
			} elsif (defined $rest_args) {
				push @{$rest_args}, $arg;
			} else {
				die "Error: Unexpected parameter '$arg'";
			}
		}
	}
}

############################################################
# data frame manipulating

sub build_sorter
{
	my ($columns, $names) = @_;
	my $n = scalar(@{$names});
	my %index = map { $_ => 1 } @{$names};
	my @sorter = ();
	for my $col (@{$columns}) {
		if (exists $index{$col}) {
			push @sorter, { name => $col, order => '+', type => 'string' };
		} elsif ($col =~ /^(.+?)([+-]?)(n?)$/) {
			my ($name, $order, $type) = ($1, $2, $3);
			print STDERR "($name)($order)($type)\n";
			if ($name =~ /^[0-9]+$/) {
				die "Error: Invalid row number '$name'! It should be between 1 and $n" if $name < 1 or $name > $n;
				$name = $names->[$name - 1];
			}
			die "Error: Unknown column '$name'" if not exists $index{$name};
			push @sorter, { name => $name, order => $order // '+', type => ($type eq 'n' ? 'number' : 'string') };
		} else {
			die "Error: Invalid sort option '$col'";
		}
	}
	return sub {
		my ($a, $b) = @_;
		my $n = 0;
		for my $s (@sorter) {
			my $name = $s->{name};
			my ($left, $right) = ($a->{$name}, $b->{$name});
			($left, $right) = ($right, $left) if $s->{order} eq '-';
			if ($s->{type} eq 'string') {
				$n = ($left cmp $right);
			} else {
				$left =~ s/^[^0-9]*([0-9]+).*$/$1/;
				$right =~ s/^[^0-9]*([0-9]+).*$/$1/;
				$n = ($left <=> $right);
			}
			last if $n != 0;
		}
		return $n;
	};
}

sub join_tsv
{
	my ($d1, $d2, $keys, $join_type) = @_;
	my %h1 = map { $d1->{names}->[$_] => $_ } (0 .. $#{$d1->{names}});
	my %h2 = map { $d2->{names}->[$_] => $_ } (0 .. $#{$d2->{names}});
	for my $item (@{$keys}) {
		delete $h1{$item->{left}};
		delete $h2{$item->{right}};
	}
	my %shared = ();
	for my $name (keys %h1) {
		$shared{$name} = 1 if exists $h2{$name};
	}
	my @names = ();
	my %map_1 = ();
	my %map_2 = ();
	for my $name (@{$d1->{names}}) {
		my $name2 = $name . (exists $shared{$name} ? '.x' : '');
		push @names, $name2;
		$map_1{$name} = $name2;
	}
	for my $name (@{$d2->{names}}) {
		next if not exists $h2{$name};
		my $name2 = $name . (exists $shared{$name} ? '.y' : '');
		push @names, $name2;
		$map_2{$name} = $name2;
	}

	my @data = ();
	my %hash = ();
	for my $i (0 .. $#{$d2->{data}}) {
		my $item = $d2->{data}->[$i];
		my $key = join("\t", map { $item->{$_->{left}} } @{$keys});
		push @{$hash{$key}}, $i;
	}
	my %joined = ();
	for my $i (0 .. $#{$d1->{data}}) {
		my $item = $d1->{data}->[$i];
		my $key = join("\t", map { $item->{$_->{right}} } @{$keys});
		my @item2 = ();
		if ($join_type eq 'inner' or $join_type eq 'right') {
			next if not exists $hash{$key};
		}
		push @item2, $d2->{data}->[$_] for @{$hash{$key}};
		push @item2, {} unless @item2;
		for my $item2 (@item2) {
			my %row = ();
			for my $name (keys %map_1) {
				$row{$map_1{$name}} = $item->{$name} // '';
			}
			for my $name (keys %map_2) {
				$row{$map_2{$name}} = $item2->{$name} // '';
			}
			push @data, \%row;
		}
		$joined{$key} = 1;
	}
	if ($join_type eq 'full' or $join_type eq 'right') {
		my %right_hash = map { $_->{left} => $_->{right} } @{$keys};
		for my $key (keys %hash) {
			next if $joined{$key};
			for my $i (@{$hash{$key}}) {
				my %row = ();
				for my $name (keys %map_2) {
					my $item2 = $d2->{data}->[$i];
					for my $name (keys %map_1) {
						if (exists $right_hash{$name}) {
							$row{$name} = $item2->{$right_hash{$name}};
						} else {
							$row{$map_1{$name}} = '';
						}
					}
					$row{$map_2{$name}} = $item2->{$name} // '';
				}
				push @data, \%row;
			}
		}
	}

	return { names => \@names, data => \@data };
}

sub is_numeric
{
	my $val = shift @_;
	return do { no warnings; $val eq ($val + 0) };
}

sub parse_cond_obj
{
	my ($s, $names) = @_;
	$s =~ s/(^\s*|\s*$)//g;
	if ($s =~ /^[0-9]/) {
		return (eval($s), 'number');
	} elsif ($s =~ /^["']/) {
		return (eval($s), 'string');
	} else {
		die "Error: No column '$s' found" if not exists $names->{$s};
		return ($s, 'var');
	}
}

sub build_filter
{
	my ($conditions, $names) = @_;
	my @filter = ();
	for my $cond (@{$conditions}) {
		die "Error: Invalid condition '$cond'" if $cond !~ /^(.+)(==|!=|<=?|>=?|=~|!~)(.+)$/;
		my ($a, $op, $b) = ($1, $2, $3);
		my ($a_type, $b_type);
		($a, $a_type) = parse_cond_obj($a, $names);
		($b, $b_type) = parse_cond_obj($b, $names);
		die "Error: No column is specified in condition '$cond'" if $a_type ne 'var' and $b_type ne 'var';
		push @filter, {
			a => { val => $a, type => $a_type },
			op => $op,
			b => { val => $b, type => $b_type }
		};
	}
	return \@filter;
}

sub check_filter_ok
{
	my ($item, $filter) = @_;
	for my $cond (@{$filter}) {
		my $op = $cond->{op};
		my ($a, $a_type) = ($cond->{a}->{val}, $cond->{a}->{type});
		$a = $item->{$a} if $a_type eq 'var';
		my ($b, $b_type) = ($cond->{b}->{val}, $cond->{b}->{type});
		$b = $item->{$b} if $b_type eq 'var';
		if ($op eq '=~') {
			return 0 unless ($a =~ $b);
		} elsif ($op eq '!~') {
			return 0 unless ($a !~ $b);
		} else {
			my $n;
			if ($a_type eq 'string' or $b_type eq 'string') {
				$n = ($a cmp $b);
			} else {
				$n = ($a <=> $b);
			}
			return 0 unless eval($n . $cond->{op} . '0');
		}
	}
	return 1;
}

sub get_unique_name
{
	my ($name, $hash) = @_;
	$name =~ s/(^\s*|\s*$)//g;
	while ($name eq '' or exists $hash->{$name}) {
		if ($name =~ /^(.*)_([0-9]*)$/) {
			$name = $1 . "_" . (($2 // 0) + 1);
		} else {
			$name .= "_1";
		}
	}
	$hash->{$name} = 1;
	return $name;
}

sub fetch_xlsx_row
{
	my ($sheet, $row) = @_;
	my @values = ();
	my %decode = ( amp => "&", lt => "<", gt => ">", "quot" => "\"", "nbsp" => " " );
	for my $col ($sheet->{MinCol} .. $sheet->{MaxCol}) {
		my $cell = $sheet->{Cells}[$row][$col];
		my $value = ((not defined $cell) ? '' : ($cell->{Val} // ''));
		$value =~ s{&([a-z]+);}{$decode{$1}//$1}gex;
		$value =~ s/[\t\n\r]/ /gm;
		push @values, $value;
	}
	return @values;
}

sub prepare_colnames
{
	my ($names, $hash) = @_;
	return map {
		my ($original_name, $name) = ($_, $_);
		$name = "_" . $name if $name =~ /^[0-9]/;
		$name = get_unique_name($name, $hash);
		#print STDERR "Note: Column '$original_name' renamed to '$name'\n" if $original_name ne $name;
		$name;
	} @{$names};
}

sub load_xlsx
{
	eval("use Spreadsheet::XLSX");
	die "Error: Perl module 'Spreadsheet::XLSX' should be installed!" if $@;

	my ($filename, $no_header) = @_;
	my %sheet_no = ();
	if ($filename =~ /^(.+):([0-9,]+)$/) {
		$filename = $1;
		%sheet_no = map { $_ => 1 } (split(",", $2));
	}
	$sheet_no{1} = 1 unless %sheet_no; # load only the first sheet by default

	my $xlsx = Spreadsheet::XLSX->new($filename);
	if (not defined $xlsx) {
		print STDERR "Error: Can not open Excel file '$filename'. " . $xlsx->error() . ".\n";
		exit 1;
	}

	my $counter = 0;
	my $d;
	for my $sheet (@{$xlsx->{Worksheet}}) {
		my @names = ();
		my %hash = ();
		my @data = ();
		if (exists $sheet_no{0} or exists $sheet_no{++$counter}) {
			for my $row ($sheet->{MinRow} .. $sheet->{MaxRow}) {
				my @values = fetch_xlsx_row($sheet, $row);
				if ($row == $sheet->{MinRow} and not $no_header) {
					@names = prepare_colnames(\@values, \%hash);
				} else {
					if ($#names < $#values) {
						push @names, map { get_unique_name('', \%hash) } (($#names + 1) .. $#values)
					}
					my %item = map { $names[$_] => $values[$_] // '' } (0 .. $#names);
					push @data, \%item;
				}
			}
		}
		my $tsv2 = { names => \@names, data => \@data };
		if (not defined $d) {
			$d = $tsv2;
		} else {
			$d = merge_tsv($d, $tsv2);
		}
	}
	return $d;
}

sub autofit_columns {
	my $worksheet = shift;
	my $col       = 0;
	for my $width (@{$worksheet->{__col_widths}}) {
		$worksheet->set_column($col, $col, $width) if $width;
		$col++;
	}
}

sub store_string_widths {

	my $worksheet = shift;
	my $col       = $_[1];
	my $token     = $_[2];

	# Ignore some tokens that we aren't interested in.
	return if not defined $token;       # Ignore undefs.
	return if $token eq '';             # Ignore blank cells.
	return if ref $token eq 'ARRAY';    # Ignore array refs.
	return if $token =~ /^=/;           # Ignore formula

	# Ignore numbers
	return if $token =~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/;

	# Ignore various internal and external hyperlinks. In a real scenario
	# you may wish to track the length of the optional strings used with
	# urls.
	return if $token =~ m{^[fh]tt?ps?://};
	return if $token =~ m{^mailto:};
	return if $token =~ m{^(?:in|ex)ternal:};

	# We store the string width as data in the Worksheet object. We use
	# a double underscore key name to avoid conflicts with future names.
	#
	my $old_width    = $worksheet->{__col_widths}->[$col];
	my $string_width = string_width($token);

	if (not defined $old_width or $string_width > $old_width) {
		# You may wish to set a minimum column width as follows.
		#return undef if $string_width < 10;

		$worksheet->{__col_widths}->[$col] = $string_width;
	}
	# Return control to write();
	return undef;
}

sub string_width {
	return 0.9 * length($_[0]) + 3;
}

sub open_file
{
	my $filename = shift @_;
	my ($mod, $con) = ("<", $filename);
	die "Error: '$filename' is a directory" if -d $filename;
	if    ($filename eq "-"     ) { $mod = "<";  $con = $STDIN; }
	elsif ($filename =~ /\.gz$/ ) { $mod = "-|"; $con = "zcat '$filename'"; }
	elsif ($filename =~ /\.bz2$/) { $mod = "-|"; $con = "bzcat '$filename'"; }
	elsif ($filename =~ /\.zip$/) { $mod = "-|"; $con = "unzip -p '$filename'"; }
	open my $fh, $mod, $con or die "Error: Can not open file '$filename'";
	return $fh;
}

sub close_file
{
	my $fh = shift @_;
	close $fh;
}

sub load_bed
{
	# Spec: https://genome.ucsc.edu/FAQ/FAQformat.html#format1
	#       https://genome.ucsc.edu/FAQ/FAQformat.html#format1.7
	my $filename = shift @_;
	my $fh = open_file($filename);
	my @names = ("chrom", "chromStart", "chromEnd", "name", "score", "strand",
		"thickStart", "thickEnd", "itemRgb", "blockCount", "blockSizes", "blockStarts");
	my @names2 = (@names[0..2], "id", "desc", @names[3..$#names]);
	my @data = ();
	my $max_column_count = 0;
	my $has_bed_detail = 0;
	my $is_current_bed_detail = 0;
	while (my $line = <$fh>) {
		chomp $line;
		if ($line =~ /^track name=/) {
			if ($line =~ /type=bedDetail/) {
				$has_bed_detail = 1;
				$is_current_bed_detail = 1;
			} else {
				$is_current_bed_detail = 0;
			}
		} else {
			my @values = split("\t", $line, -1);
			die "Error: Unexpected column count" if scalar(@values) > ($is_current_bed_detail ? scalar(@names2) : scalar(@names));
			$max_column_count = scalar(@values) if $max_column_count < scalar(@values);
			my %item = map { ($is_current_bed_detail ? $names2[$_] : $names[$_]) => ($values[$_] // '') } (0 .. $#values);
			push @data, \%item;
		}
	}
	close_file($fh);
	if ($has_bed_detail) {
		@names2 = @names2[0 .. ($max_column_count - 1)];
		return { names => \@names2, data => \@data };
	} else {
		@names = @names[0 .. ($max_column_count - 1)];
		return { names => \@names, data => \@data };
	}
}

sub load_psl
{
	# Spec: https://genome.ucsc.edu/FAQ/FAQformat.html#format2
	my $filename = shift @_;
	my $fh = open_file($filename);
	my @names = ("matches", "misMatches", "repMatches", "nCount",
		"qNumInsert", "qBaseInsert", "tNumInsert", "tBaseInsert", "strand",
		"qName", "qSize", "qStart", "qEnd", "tName", "tSize", "tStart", "tEnd",
		"blockCount", "blockSizes", "qStarts", "tStarts");
	my @data = ();
	my $head_skipped = 1;
	while (my $line = <$fh>) {
		chomp $line;
		if ($fh->input_line_number == 1 and $line =~ /^psLayout/) {
			$head_skipped = 0;
		} elsif (not $head_skipped) {
			$head_skipped = 1 if $line =~ /^[-][-]*$/;
		} else {
			my @values = split("\t", $line, -1);
			die "Error: Unexpected column count" if $#values != $#names;
			my %item = map { $names[$_] => ($values[$_] // '') } (0 .. $#values);
			push @data, \%item;
		}
	}
	close_file($fh);
	return { names => \@names, data => \@data };
}

sub is_valid_xslx_ref
{
	my $filename = shift;
	if ($filename =~ /^(.*\.xlsx)(|:([0-9,]+))$/) {
		if (-e $1) {
			return 1;
		}
	}
	return 0;
}

sub load_tsv
{
	my ($filename, $no_header, $sep) = @_;
	my @names = ();
	my @data = ();
	die "Error: Input file '$filename' does not exist" unless -e $filename or is_valid_xslx_ref($filename);
	my ($mod, $con) = ("<", $filename);
	$sep = "\t" if not defined $sep or $sep eq '';
	$sep = ',' if $filename =~ /\.csv(|\.gz|\.bz2)$/;
	if (is_valid_xslx_ref($filename)) { return load_xlsx($filename, $no_header); }
	if ($filename =~ /\.bed(|\.gz|\.bz2)$/) { return load_bed($filename); }
	if ($filename =~ /\.psl(|\.gz|\.bz2)$/) { return load_psl($filename); }
	my $fh = open_file($filename);
	my %hash = ();
	while (my $line = <$fh>) {
		chomp $line;
		if ($fh->input_line_number == 1 and not $no_header) {
			@names = split($sep, $line, -1);
			@names = prepare_colnames(\@names, \%hash);
		} else {
			my @values = split($sep, $line, -1);
			if ($#names < $#values) {
				push @names, map { get_unique_name('', \%hash) } (($#names + 1) .. $#values)
			}
			my %item = map { $names[$_] => ($values[$_] // '') } (0 .. $#names);
			push @data, \%item;
		}
	}
	close_file($fh);
	return { names => \@names, data => \@data };
}

sub has_na
{
	my ($item, $names) = @_;
	for my $name (@{$names}) {
		return 1 unless ($item->{$name} // '');
	}
	return 0;
}

sub write_tsv
{
	my ($d, $out_file, $opts) = @_;
	my $sep = $opts->{sep} // "\t";
	my $no_header = $opts->{no_header} // 0;
	my $col_index = $opts->{col_index};
	my $show_row_numbers = $opts->{show_row_numbers} // 0;
	my $mode = $opts->{mode} // 'cat';
	my @names;
	if (not exists $opts->{col_index}) {
		@names = @{$d->{names}};
	} else {
		@names = map { $d->{names}->[$_ - 1] } @{$opts->{col_index}};
	}
	open my $fh, ">", $out_file or die "Error: Can not write to file '$out_file'";
	if (not $no_header and $mode ne 'view') {
		print $fh "\t" if $show_row_numbers;
		print $fh join($sep, @names), "\n";
	}
	if (exists $opts->{row_index}) {
		for my $r (@{$opts->{row_index}}) {
			my ($a, $b) = ($r->{start}, $r->{end});
			my $delta = ($a <= $b ? 1 : -1);
			for (my $i = $a; $i != $b + $delta; $i += $delta) {
				print $fh join($sep, map { $d->{data}->[$i - 1]->{$_} // '' } @names), "\n";
			}
		}
	} elsif (exists $opts->{sorter}) {
		my $data = $d->{data};
		my @rows = sort { $opts->{sorter}->($data->[$a], $data->[$b]) } (0 .. $#{$data});
		for my $i (@rows) {
			print $fh join($sep, map { $d->{data}->[$i]->{$_} // '' } @names), "\n";
		}
	} elsif ($mode eq 'view') {
		my $max_name_width = length('column');
		my $names = $d->{names};
		my $id_width = get_text_width(scalar(@{$names}) - 1);
		my $max_id_width = ($id_width >= length('id') ? $id_width : length('id'));
		for my $name (@{$names}) {
			my $width = get_text_width($name);
			$max_name_width = $width if $max_name_width < $width;
		}
		my $row = 0;
		for my $item (@{$d->{data}}) {
			print $fh "# row " . ++$row . "\n";
			print $fh join("  ",
				align_text('id', $max_id_width),
				align_text('column', $max_name_width),
				'value'), "\n";
			my $column_id = 0;
			for my $name (@{$names}) {
				print $fh join("  ",
					align_text(++$column_id, $max_id_width),
					align_text($name, $max_name_width),
					$item->{$name}), "\n";
			}
			print $fh "\n";
		}
	} else {
		my $row = 0;
		for my $item (@{$d->{data}}) {
			++$row;
			next if exists $opts->{filter} and not check_filter_ok($item, $opts->{filter});
			next if exists $opts->{remove_na} and has_na($item, \@names);
			print $fh $row, "\t" if $show_row_numbers;
			print $fh join($sep, map { $item->{$_} // '' } (@names)), "\n";
		}
	}
	close $fh;
}

sub align_text
{
	my ($s, $w) = @_;
	$s = '' unless defined $s;
	if ($w > 0) {
		my $tw = get_text_width($s);
		if ($tw < $w) {
			$s .= (' ' x ($w - $tw));
		} elsif ($tw > $w) {
			$s = trim_text_at_width($s, $w, "...");
		}
	}
	return $s;
}

sub merge_tsv
{
	my ($a, $b) = @_;
	my @names = @{$a->{names}};
	my %hash = map { $_ => 1 } @names;
	for my $name (@{$b->{names}}) {
		push @names, $name unless exists $hash{$name};
		$hash{$name} = 1;
	}
	return { names => \@names, data => [ @{$a->{data}}, @{$b->{data}} ] };
}

sub skip_characters_in_range
{
	my ($s, $offset, $i, $lower, $upper) = @_;
	my $c;
	for (;;) {
		$c = ord(substr($s, $offset + $i, 1));
		last unless $c >= $lower and $c <= $upper;
		++$i;
	}
	return ($i, $c);
}

sub get_character_width
{
	my ($s, $offset) = @_;
	my $c = ord(substr($s, $offset, 1));
	my ($byte_count, $width);
	if ($c == 0x1B) {  # ANSI escape code
		my $c1 = ord(substr($s, $offset + 1, 1));
		if ($c1 == ord('[')) {  # Control Sequence Introducer
			my $i = 2;
			($i, $c1) = skip_characters_in_range($s, $offset, $i, 0x30, 0x3F);
			($i, $c1) = skip_characters_in_range($s, $offset, $i, 0x20, 0x2F);
			die "Unexpected CSI character '" . sprintf("%02X", $c1) . "' at byte offset '" . ($offset + $i) . "' of '$s'!" unless $c1 >= 0x40 and $c1 <= 0x7E;
			$byte_count = $i + 1;
			$width = 0;
		} else {
			die "Unexpected ANSI escape code '" . sprintf("%02X", $c1) . "' at byte offset '$offset' of '$s'!" unless $c1 >= 0x40 and $c1 <= 0x5F;
			$byte_count = 2;
			$width = 0;
		}
	} elsif ($c <= 0x7F) {  # U+0000 ~ U+007F: 0XXXXXXX
		$byte_count = 1;
		$width = 1;
	} elsif ($c <= 0xE0) {  # U+0080 ~ U+07FF: 110XXXXX 10XXXXXX
		$byte_count = 2;
		$width = 2;
	} elsif ($c <= 0xF0) {  # U+0800 ~ U+FFFF: 1110XXXX 10XXXXXX 10XXXXXX
		my ($c1, $c2) = map { ord(substr($s, $offset + $_, 1)) } (1, 2);
		$byte_count = 3;
		$width = (($c == 0xE2 and ($c1 >= 0x84 and $c1 <= 0xB9) and ($c2 >= 0x80 and $c2 <= 0xBF)) ? 1 : 2);
	} elsif ($c <= 0xF8) {  # U+10000 ~ U+1FFFFF: 11110XXXX 10XXXXXX 10XXXXXX 10XXXXXX
		$byte_count = 4;
		$width = 2;
	} elsif ($c <= 0xFC) {  # U+200000 ~ U+3FFFFFF: 11110XXXX 10XXXXXX 10XXXXXX 10XXXXXX 10XXXXXX
		$byte_count = 5;
		$width = 2;
	} elsif ($c <= 0xFE) {  # U+4000000 ~ U+7FFFFFFF: 11110XXXX 10XXXXXX 10XXXXXX 10XXXXXX 10XXXXXX 10XXXXXX
		$byte_count = 6;
		$width = 2;
	} else {
		die "Unexpected UTF8 character '" . sprintf("%02X", $c) . "' at byte offset '$offset' of '$s'!";
	}
	die "Truncated string at byte offset '$offset' of '$s'!" if $offset + $byte_count > length($s);
	return ($byte_count, $width);
}

sub get_text_width
{
	my $s = shift // '';
	my $width = 0;
	for (my $i = 0; $i < length($s);) {
		my ($byte_count, $w) = get_character_width($s, $i);
		$i += $byte_count;
		$width += $w;
	}
	return $width;
}

sub trim_text_at_width
{
	my ($s, $expected_width, $append_suffix) = @_;
	my $width_upper_limit = $expected_width - get_text_width($append_suffix);
	my ($i, $width) = (0, 0);
	for (; $i < length($s);) {
		my ($byte_count, $w) = get_character_width($s, $i);
		last if $width + $byte_count > $width_upper_limit;
		$i += $byte_count;
		$width += $w;
	}
	return substr($s, 0, $i) . $append_suffix . (" " x ($width_upper_limit - $width));
}

sub quantile
{
	my ($data, $prob) = @_;
	my $index = (scalar(@{$data}) + 1) * $prob - 1;
	my $base_value = $data->[int($index)];
	return $base_value + ($data->[int($index) + 1] - $base_value) * ($index - int($index));
}

sub mean
{
	my $data = shift @_;
	if (scalar(@{$data}) == 0) {
		return "NA";
	} else {
		my $sum = 0;
		for my $value (@{$data}) {
			$sum += $value;
		}
		return $sum / scalar(@{$data});
	}
}

sub write_align
{
	my ($d, $no_header, $out_file, $max_width, $max_check) = @_;
	my %width = map { $_ => ($no_header ? 0 : get_text_width($_)) } @{$d->{names}};
	my $counter = 0;
	for my $item (@{$d->{data}}) {
		for my $name (@{$d->{names}}) {
			if ($width{$name} < $max_width) {
				my $width = get_text_width($item->{$name});
				$width = $max_width if $width > $max_width;
				$width{$name} = $width if $width{$name} < $width;
			}
		}
		last if ++$counter >= $max_check;
	}
	open my $ofh, '>', $out_file or die "Error: Can not create file '$out_file'";
	if (not $no_header) {
		print $ofh join("  ", map { align_text($_, $width{$_}) } @{$d->{names}}), "\n";
	}
	for my $item (@{$d->{data}}) {
		print $ofh join("  ", map { align_text($item->{$_}, $width{$_}) } @{$d->{names}}), "\n";
	}
	close $ofh;
}

sub write_view
{
	my ($d, $out_file) = @_;
	open my $ofh, '>', $out_file or die "Error: Can not create file '$out_file'";
	write_tsv($d, $out_file, { mode => 'view' });
}

sub write_column
{
	my ($d, $out_file) = @_;
	my $column = {
		names => [ "number", "colname" ],
		data => [ map { {
				number => $_ + 1,
				colname => $d->{names}->[$_]
			} } (0 .. $#{$d->{names}}) ]
	};
	write_tsv($column, $out_file);
}

sub write_dim
{
	my ($d, $out_file) = @_;
	my $res = {
		names => [ "colname", "value" ],
		data => [
			{ colname => 'columns', 'value' => scalar(@{$d->{names}}) },
			{ colname => 'rows', 'value' => scalar(@{$d->{data}}) }
		]
	};
	write_tsv($res, $out_file);
}

sub write_count
{
	my ($d, $out_file, $col_index) = @_;
	my @names = map { $d->{names}->[$_ - 1] } @{$col_index};
	my %counter = ();
	for my $i (0 .. $#{$d->{data}}) {
		my $key = join("\t", map { $d->{data}->[$i]->{$_} } @names);
		$counter{$key} = { index => $i, count => 0 } if not exists $counter{$key};
		++$counter{$key}->{count};
	}
	my $res = {
		names => [ "n", map { $d->{names}->[$_ - 1] } @{$col_index} ],
		data => [
			map {
				my $index = $counter{$_}->{index};
				{
					n => $counter{$_}->{count},
					map { $_ => $d->{data}->[$index]->{$_} } @names
				}
			} sort {
				$counter{$a}->{count} <=> $counter{$b}->{count}
				//
				$counter{$a}->{index} <=> $counter{$b}->{index}
			} keys(%counter)
		]
	};
	write_tsv($res, $out_file);
}

sub expand_row_index
{
	my ($x, $n) = @_;
	my @s = split(',', $x);
	if (scalar(@s) > 1) {
		return map { expand_row_index($_, $n) } @s;
	}
	if ($x =~ /^[0-9]+$/) {
		return ( { start => $x, end => $x } ) if $x >= 1 and $x <= $n;
		die "Error: Invalid row number '$x'! It should be between 1 and $n";
	} elsif ($x =~ /^(.*)(\-|:|\.\.)(.*)$/) {
		my ($a, $b) = ($1, $3);
		$a = 1 if $a eq '';
		$b = $n if $b eq '';
		return ( { start => $a, end => $b } ) if $a >= 1 and $a <= $n and $b >= 1 and $b <= $n;
		die "Error: Invalid row range '$x'! It should be between 1 and $n";
	} else {
		die "Error: Invalid row number '$x'!";
	}
}

sub expand_column_index
{
	my ($x, $dict, $columns, $maybe_range) = @_;
	my $n = scalar(@{$columns});
	return $dict->{$x} if exists $dict->{$x};
	my @s = split(',', $x);
	if (scalar(@s) > 1) {
		return map { expand_column_index($_, $dict, $columns, 1) } (@s);
	}
	if ($maybe_range and ($x =~ /^(.*)(\-|:|\.\.)(.*)$/)) {
		my ($a, $b) = ($1, $3);
		$a = 1 if $a eq '';
		$b = $n if $b eq '';
		$a = expand_column_index($a, $dict, $columns, 0);
		$b = expand_column_index($b, $dict, $columns, 0);
		if ($a <= $b) { return ($a .. $b); } else { return reverse ($b .. $a); }
	}
	if ($x =~ /^[0-9]+$/) {
		return $x if $x >= 1 and $x <= $n;
		die "Error: Invalid column number '$x'! It should be between 1 and $n";
	} else {
		die "Error: Invalid column name '$x'! Available colum names: ('" . join("', '", @{$columns}) . "')"
	}
}

sub write_transpose
{
	my ($d, $out_file) = @_;
	my $res = {
		names => [ "colname", map { "row_" . ($_ + 1) } (0 .. $#{$d->{data}}) ],
		data => [ map {
				my $name = $_;
				{
					"colname" => $name,
					map { "row_" . ($_ + 1) => $d->{data}->[$_]->{$name} } (0 .. $#{$d->{data}})
				}
			} @{$d->{names}} ]
	};
	write_tsv($res, $out_file);
}

############################################################
# version & usages

sub get_version_string
{
	chomp(my $hashcode = `md5sum $0`);
	my $version_suffix = '';
	if ($hashcode ne '') {
		$version_suffix = " (" . substr($hashcode, 0, 7) . ")";
	}
	return "$VERSION$version_suffix";
}

sub print_usage
{
	print '
Program: Toolkits for TSV (TAB-Separated Values) File
Version: ' . get_version_string() . '
Author : Linlin Yan <yanlinlin82@gmail.com>
License: MIT 2019-2020

Usage: ' . $APPNAME . ' <command> [options]

Commands:
  - Viewing
      cat           show original content
      align         align columns
      view          view file content in pretty better format
      column        list column names

  - Counting
      dim           show matrix dimension
      count         count column values

  - Selecting
      select        select columns
      select-rows   select rows
      head          select head n rows
      tail          select tail n rows
      filter        filter by conditions

  - Manipulating
      cleanup       remove empty rows or columns
      transpose     matrix transpose
      sort          sort by column(s)
      merge         merge multiple files
      join          join two tables by key column(s)
      summary       summary each column

  - Writing
      to-csv        write to CSV file
      to-xlsx       write to Excel (.xlsx) file

  - Others
      version       show program version

';
	exit 1;
}

sub print_usage_cat
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt>

Options:
   -o <FILE>     Output file, default: " . fetch_arg($opts, '-o') . "
   -s <CHAR>     Separate character, default: <TAB>
   -n            Show row numbers
   --no-header   Input file does not have header line

";
	exit 1;
}

sub print_usage_align
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt>

Options:
   -o <FILE>           Output file, default: " . fetch_arg($opts, '-o') . "
   -s <CHAR>           Separate character, default: <TAB>
   --no-header         Input file does not have header line
   --max-width <int>   Maximum column width for each column, default: " . fetch_arg($opts, '--max-width') . "
   --max-check <int>   Maximum checking lines for calculate column width, default: " . fetch_arg($opts, '--max-check') . "

";
	exit 1;
}

sub print_usage_view
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt>

Options:
   -o <FILE>     Output file, default: " . fetch_arg($opts, '-o') . "
   -s <CHAR>     Separate character, default: <TAB>
   --no-header   Input file does not have header line

";
	exit 1;
}

sub print_usage_column
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt>

Options:
   -o <FILE>     Output file, default: " . fetch_arg($opts, '-o') . "
   -s <CHAR>     Separate character, default: <TAB>
   --no-header   Input file does not have header line

";
	exit 1;
}

sub print_usage_dim
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt>

Options:
   -o <FILE>     Output file, default: " . fetch_arg($opts, '-o') . "
   -s <CHAR>     Separate character, default: <TAB>
   --no-header   Input file does not have header line

";
	exit 1;
}

sub print_usage_count
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt> <columns>...

Options:
   -o <FILE>     Output file, default: " . fetch_arg($opts, '-o') . "
   -s <CHAR>     Separate character, default: <TAB>
   --no-header   Input file does not have header line

";
	exit 1;
}

sub print_usage_select
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt> <columns>...

Options:
   -o <FILE>     Output file, default: " . fetch_arg($opts, '-o') . "
   -s <CHAR>     Separate character, default: <TAB>
   --no-header   Input file does not have header line

Notes:
  1. <columns> can be either numbers or names, separated by ',' or space.
     e.g.:  $cmd_prefix$cmd in.txt id,name age
            $cmd_prefix$cmd in.txt 1,4 8
            $cmd_prefix$cmd in.txt 1,age 9
  2. column numbers are 1-based integers.
  3. column range is specified as format '<start>-<end>', '<start>:<end>' or '<start>..<end>'.
     e.g.:  $cmd_prefix$cmd in.txt id..age
            $cmd_prefix$cmd in.txt 1-9
            $cmd_prefix$cmd in.txt -5
            $cmd_prefix$cmd in.txt 5-

";
	exit 1;
}

sub print_usage_select_rows
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt> <rows>...

Options:
   -o <FILE>     Output file, default: " . fetch_arg($opts, '-o') . "
   -s <CHAR>     Separate character, default: <TAB>
   --no-header   Input file does not have header line

Notes:
  1. <rows> can be either numbers or names, separated by ',' or space.
     e.g.:  $cmd_prefix$cmd in.txt 1,3-5 10
  2. row numbers are 1-based integers.

";
	exit 1;
}

sub print_usage_head
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt>

Options:
   -n <INT>      Show first n rows, default: " . fetch_arg($opts, '-n') . "
   -o <FILE>     Output file, default: " . fetch_arg($opts, '-o') . "
   -s <CHAR>     Separate character, default: <TAB>
   --no-header   Input file does not have header line

Note:
  1. if '-n <INT>' is leading with '-', it will print all but the last <INT> lines.
     e.g.:  $cmd_prefix in.txt -n-10  # remove last 10 lines.

";
	exit 1;
}

sub print_usage_tail
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt>

Options:
   -n <INT>      Show last n rows, default: " . fetch_arg($opts, '-n') . "
   -o <FILE>     Output file, default: " . fetch_arg($opts, '-o') . "
   -s <CHAR>     Separate character, default: <TAB>
   --no-header   Input file does not have header line

Note:
  1. if '-n <INT>' is leading with '-', it will print all but the first <INT> lines.
     e.g.:  $cmd_prefix in.txt -n-10  # remove first 10 lines.

";
	exit 1;
}

sub print_usage_filter
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt> <condition>...

Options:
   -o <FILE>     Output file, default: " . fetch_arg($opts, '-o') . "
   -s <CHAR>     Separate character, default: <TAB>
   --no-header   Input file does not have header line

Notes:
  1. <condition> can be logical expression.
     e.g.:  $cmd_prefix$cmd in.txt 'age>=18'
            $cmd_prefix$cmd in.txt 'age>=18' 'sex==\"male\"'

";
	exit 1;
}

sub print_usage_cleanup
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt>

Options:
   -o <FILE>     Output file, default: " . fetch_arg($opts, '-o') . "
   -s <CHAR>     Separate character, default: <TAB>
   --no-header   Input file does not have header line

";
	exit 1;
}

sub print_usage_transpose
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt>

Options:
   -o <FILE>     Output file, default: " . fetch_arg($opts, '-o') . "
   -s <CHAR>     Separate character, default: <TAB>
   --no-header   Input file does not have header line

";
	exit 1;
}

sub print_usage_sort
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt> <columns>...

Options:
   -o <FILE>     Output file, default: " . fetch_arg($opts, '-o') . "
   -s <CHAR>     Separate character, default: <TAB>
   --no-header   Input file does not have header line

Notes:
  1. <columns> can be either numbers or names, separated by space.
     e.g.:  $cmd_prefix$cmd in.txt 2
            $cmd_prefix$cmd in.txt 2 3
            $cmd_prefix$cmd in.txt age
            $cmd_prefix$cmd in.txt age sex
            $cmd_prefix$cmd in.txt 2 sex
  2. suffix '+' or '-' can be appended to column numbers/names to specify
     the sorting order, ascending or descending.
     e.g.:  $cmd_prefix$cmd in.txt 2+ 3-
            $cmd_prefix$cmd in.txt age+ sex-
  3. suffix 'n' can be appended to column numbers/names (after '+' or '-')
     to specify treating column value as number when sorting.
     e.g.:  $cmd_prefix$cmd in.txt 2+n
            $cmd_prefix$cmd in.txt age+n

";
	exit 1;
}

sub print_usage_merge
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in-1.txt> <in-2.txt>...
       $cmd_prefix$cmd [options] -f <file-list.txt>

Options:
   -o <FILE>     Output file, default: " . fetch_arg($opts, '-o') . "
   -s <CHAR>     Separate character, default: <TAB>
   -f <FILE>     Input file list, each line contains one file path
   --no-header   Input file does not have header line

";
	exit 1;
}

sub print_usage_join
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in-1.txt> <in-2.txt> [colnames]...

Options:
   -o <FILE>                   Output file, default: " . fetch_arg($opts, '-o') . "
   -s <CHAR>                   Separate character, default: <TAB>
   --no-header                 Input file does not have header line
   -t {inner|left|right|full}  Joining type, default: inner

";
	exit 1;
}

sub print_usage_summary
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt>

Options:
   -o <FILE>     Output file, default: " . fetch_arg($opts, '-o') . "
   -s <CHAR>     Separate character, default: <TAB>
   --no-header   Input file does not have header line

";
	exit 1;
}

sub print_usage_to_csv
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt>

Options:
   -o <FILE>     Output file, default: " . fetch_arg($opts, '-o') . "
   -s <CHAR>     Separate character, default: <TAB>
   --no-header   Input file does not have header line

";
	exit 1;
}

sub print_usage_to_xlsx
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] [out.xlsx] <in.txt>...

Options:
   -s <CHAR>     Separate character, default: <TAB>
   --no-header   Input file does not have header line

Notes:
  1. For multiple input file, each file will be written into a sheet.
  2. Input file could be specified as 'NAME=filename' to set sheet name.
     e.g.:  $cmd_prefix$cmd out.xlsx Index=index.txt Details=details.txt

";
	exit 1;
}

############################################################
# commands

sub do_cat
{
	my ($cmd, @args) = @_;

	my ($in_file, $no_header, $show_row_numbers, $out_file, $sep) = ('', 0, 0, $STDOUT, "\t");
	my $opts = {
		'-o' => \$out_file,
		'-s' => \$sep,
		'-n' => sub { $show_row_numbers = 1; },
		'--no-header' => sub { $no_header = 1; },
	};
	parse_args($cmd, \@args, \&print_usage_cat, $opts, [ \$in_file ]);

	if ($in_file eq '') {
		print_usage_cat($cmd, $opts) if -t STDIN;
		$in_file = $STDIN;
	}

	my $d = load_tsv($in_file, $no_header, $sep);
	write_tsv($d, $out_file, { show_row_numbers => $show_row_numbers });
	exit 0;
}

sub do_align
{
	my ($cmd, @args) = @_;

	my ($in_file, $no_header, $out_file, $sep) = ('', 0, $STDOUT, "\t");
	my $max_width = 100;
	my $max_check = 1000;
	my $opts = {
		'-o' => \$out_file,
		'-s' => \$sep,
		'--no-header' => sub { $no_header = 1; },
		'--max-width' => \$max_width,
		'--max-check' => \$max_check,
	};
	parse_args($cmd, \@args, \&print_usage_align, $opts, [ \$in_file ]);

	if ($in_file eq '') {
		print_usage_align($cmd, $opts) if -t STDIN;
		$in_file = $STDIN;
	}

	my $d = load_tsv($in_file, $no_header, $sep);
	write_align($d, $no_header, $out_file, $max_width, $max_check);
	exit 0;
}

sub do_view
{
	my ($cmd, @args) = @_;

	my ($in_file, $no_header, $out_file, $sep) = ('', 0, $STDOUT, "\t");
	my $opts = {
		'-o' => \$out_file,
		'-s' => \$sep,
		'--no-header' => sub { $no_header = 1; },
	};
	parse_args($cmd, \@args, \&print_usage_view, $opts, [ \$in_file ]);

	if ($in_file eq '') {
		print_usage_view($cmd, $opts) if -t STDIN;
		$in_file = $STDIN;
	}

	my $d = load_tsv($in_file, $no_header, $sep);
	write_view($d, $out_file);
	exit 0;
}

sub do_column
{
	my ($cmd, @args) = @_;

	my ($in_file, $no_header, $out_file, $sep) = ('', 0, $STDOUT, "\t");
	my $opts = {
		'-o' => \$out_file,
		'-s' => \$sep,
		'--no-header' => sub { $no_header = 1; },
	};
	parse_args($cmd, \@args, \&print_usage_column, $opts, [ \$in_file ]);

	if ($in_file eq '') {
		print_usage_column($cmd, $opts) if -t STDIN;
		$in_file = $STDIN;
	}

	my $d = load_tsv($in_file, $no_header, $sep);
	write_column($d, $out_file);
	exit 0;
}

sub do_dim
{
	my ($cmd, @args) = @_;

	my ($in_file, $no_header, $out_file, $sep) = ('', 0, $STDOUT, "\t");
	my $opts = {
		'-o' => \$out_file,
		'-s' => \$sep,
		'--no-header' => sub { $no_header = 1; },
	};
	parse_args($cmd, \@args, \&print_usage_dim, $opts, [ \$in_file ]);

	if ($in_file eq '') {
		print_usage_dim($cmd, $opts) if -t STDIN;
		$in_file = $STDIN;
	}

	my $d = load_tsv($in_file, $no_header, $sep);
	write_dim($d, $out_file);
	exit 0;
}

sub do_count
{
	my ($cmd, @args) = @_;

	my ($in_file, $no_header, $out_file, $sep) = ('', 0, $STDOUT, "\t");
	my $opts = {
		'-o' => \$out_file,
		'-s' => \$sep,
		'--no-header' => sub { $no_header = 1; },
	};
	my @columns = ();
	parse_args($cmd, \@args, \&print_usage_count, $opts, [ \$in_file ], \@columns);

	if ($in_file ne '' and not -e $in_file and not -t STDIN) {
		unshift @columns, $in_file;
		$in_file = $STDIN;
	}
	print_usage_count($cmd, $opts) if $in_file eq '';

	my $d = load_tsv($in_file, $no_header, $sep);
	my %dict = map { $d->{names}->[$_] => $_ + 1 } (0 .. $#{$d->{names}});
	my @col_index;
	if (@columns) {
		@col_index = map { expand_column_index($_, \%dict, $d->{names}, 1) } (@columns);
	} else {
		@col_index = (1 .. scalar(@{$d->{names}}));
	}
	write_count($d, $out_file, \@col_index);
	exit 0;
}

sub do_select
{
	my ($cmd, @args) = @_;

	my ($in_file, $no_header, $out_file, $sep) = ('', 0, $STDOUT, "\t");
	my $opts = {
		'-o' => \$out_file,
		'-s' => \$sep,
		'--no-header' => sub { $no_header = 1; },
	};
	my @columns = ();
	parse_args($cmd, \@args, \&print_usage_select, $opts, [ \$in_file ], \@columns);

	if ($in_file ne '' and not -e $in_file and not -t STDIN) {
		unshift @columns, $in_file;
		$in_file = $STDIN;
	}
	print_usage_select($cmd, $opts) if $in_file eq '' or not @columns;

	my $d = load_tsv($in_file, $no_header, $sep);
	my %dict = map { $d->{names}->[$_] => $_ + 1 } (0 .. $#{$d->{names}});
	my @col_index = map { expand_column_index($_, \%dict, $d->{names}, 1) } (@columns);
	write_tsv($d, $out_file, { no_header => $no_header, col_index => \@col_index });
	exit 0;
}

sub do_select_rows
{
	my ($cmd, @args) = @_;

	my ($in_file, $no_header, $out_file, $sep) = ('', 0, $STDOUT, "\t");
	my $opts = {
		'-o' => \$out_file,
		'-s' => \$sep,
		'--no-header' => sub { $no_header = 1; },
	};
	my @rows = ();
	parse_args($cmd, \@args, \&print_usage_select_rows, $opts, [ \$in_file ], \@rows);

	if ($in_file ne '' and not -e $in_file and not -t STDIN) {
		unshift @rows, $in_file;
		$in_file = $STDIN;
	}
	print_usage_select_rows($cmd, $opts) if $in_file eq '' or not @rows;

	my $d = load_tsv($in_file, $no_header, $sep);
	my $n = scalar(@{$d->{data}});
	my @row_index = map { expand_row_index($_, $n) } (@rows);
	write_tsv($d, $out_file, { no_header => $no_header, row_index => \@row_index });
	exit 0;
}

sub do_head
{
	my ($cmd, @args) = @_;

	my ($in_file, $row_count, $no_header, $out_file, $sep) = ('', 10, 0, $STDOUT, "\t");
	my $opts = {
		'-n' => \$row_count,
		'-o' => \$out_file,
		'-s' => \$sep,
		'--no-header' => sub { $no_header = 1; },
	};
	parse_args($cmd, \@args, \&print_usage_head, $opts, [ \$in_file ]);

	if ($in_file eq '') {
		print_usage_head($cmd, $opts) if -t STDIN;
		$in_file = $STDIN;
	}

	my $d = load_tsv($in_file, $no_header, $sep);
	die "Error: Invalid value '$row_count' for '-n'" if $row_count !~ /^[-+]?[0-9]+$/;
	my $n = scalar(@{$d->{data}});
	my @row_index = ();
	if ($row_count > 0) {
		$row_count = $n if $row_count > $n;
		push @row_index, { start => 1, end => $row_count };
	} elsif ($row_count < 0) {
		$row_count = -$n if $row_count < -$n;
		push @row_index, { start => 1, end => $n + $row_count } if $row_count > -$n;
	}
	write_tsv($d, $out_file, { no_header => $no_header, row_index => \@row_index });
	exit 0;
}

sub do_tail
{
	my ($cmd, @args) = @_;

	my ($in_file, $row_count, $no_header, $out_file, $sep) = ('', 10, 0, $STDOUT, "\t");
	my $opts = {
		'-n' => \$row_count,
		'-o' => \$out_file,
		'-s' => \$sep,
		'--no-header' => sub { $no_header = 1; },
	};
	parse_args($cmd, \@args, \&print_usage_tail, $opts, [ \$in_file ]);

	if ($in_file eq '') {
		print_usage_tail($cmd, $opts) if -t STDIN;
		$in_file = $STDIN;
	}

	my $d = load_tsv($in_file, $no_header, $sep);
	die "Error: Invalid value '$row_count' for '-n'" if $row_count !~ /^[-+]?[0-9]+$/;
	my $n = scalar(@{$d->{data}});
	my @row_index = ();
	if ($row_count > 0) {
		$row_count = $n if $row_count > $n;
		push @row_index, { start => $n - $row_count + 1, end => $n };
	} elsif ($row_count < 0) {
		$row_count = -$n if $row_count < -$n;
		push @row_index, { start => 1 - $row_count, end => $n } if $row_count > -$n;
	}
	write_tsv($d, $out_file, { no_header => $no_header, row_index => \@row_index });
	exit 0;
}

sub do_filter
{
	my ($cmd, @args) = @_;

	my ($in_file, $no_header, $out_file, $sep) = ('', 0, $STDOUT, "\t");
	my $opts = {
		'-o' => \$out_file,
		'-s' => \$sep,
		'--no-header' => sub { $no_header = 1; },
	};
	my @conditions = ();
	parse_args($cmd, \@args, \&print_usage_filter, $opts, [ \$in_file ], \@conditions);

	if ($in_file ne '' and not -e $in_file and not -t STDIN) {
		unshift @conditions, $in_file;
		$in_file = $STDIN;
	}
	print_usage_filter($cmd, $opts) if $in_file eq '' or not @conditions;

	my $d = load_tsv($in_file, $no_header, $sep);
	my %names = map { $_ => 1 } @{$d->{names}};
	my $filter = build_filter(\@conditions, \%names);
	write_tsv($d, $out_file, { filter => $filter });
	exit 0;
}

sub do_cleanup
{
	my ($cmd, @args) = @_;

	my ($in_file, $no_header, $out_file, $sep) = ('', 0, $STDOUT, "\t");
	my $opts = {
		'-o' => \$out_file,
		'-s' => \$sep,
		'--no-header' => sub { $no_header = 1; },
	};
	parse_args($cmd, \@args, \&print_usage_cleanup, $opts, [ \$in_file ]);

	if ($in_file eq '') {
		print_usage_cleanup($cmd, $opts) if -t STDIN;
		$in_file = $STDIN;
	}

	my $d = load_tsv($in_file, $no_header, $sep);
	my @col_index = ();
	for my $i (0 .. $#{$d->{names}}) {
		my $name = $d->{names}->[$i];
		my $has_data = 0;
		for my $item (@{$d->{data}}) {
			if ($item->{$name} // '') { $has_data = 1; last; }
		}
		push @col_index, $i + 1 if $has_data;
	}
	write_tsv($d, $STDOUT, { col_index => \@col_index, remove_na => 1 });
	exit 0;
}

sub do_transpose
{
	my ($cmd, @args) = @_;

	my ($in_file, $no_header, $out_file, $sep) = ('', 0, $STDOUT, "\t");
	my $opts = {
		'-o' => \$out_file,
		'-s' => \$sep,
		'--no-header' => sub { $no_header = 1; },
	};
	parse_args($cmd, \@args, \&print_usage_transpose, $opts, [ \$in_file ]);

	if ($in_file eq '') {
		print_usage_transpose($cmd, $opts) if -t STDIN;
		$in_file = $STDIN;
	}

	my $d = load_tsv($in_file, $no_header, $sep);
	write_transpose($d, $out_file);
	exit 0;
}

sub do_sort
{
	my ($cmd, @args) = @_;

	my ($in_file, $no_header, $out_file, $sep) = ('', 0, $STDOUT, "\t");
	my $opts = {
		'-o' => \$out_file,
		'-s' => \$sep,
		'--no-header' => sub { $no_header = 1; },
	};
	my @columns = ();
	parse_args($cmd, \@args, \&print_usage_sort, $opts, [ \$in_file ], \@columns);

	if ($in_file eq '') {
		print_usage_sort($cmd, $opts) if -t STDIN;
		$in_file = $STDIN;
	}

	my $d = load_tsv($in_file, $no_header, $sep);
	my $sorter = build_sorter(\@columns, $d->{names});
	write_tsv($d, $STDOUT, { sorter => $sorter });
	exit 0;
}

sub do_merge
{
	my ($cmd, @args) = @_;

	my ($no_header, $out_file, $sep, $file_list) = (0, $STDOUT, "\t", '');
	my $opts = {
		'-o' => \$out_file,
		'-s' => \$sep,
		'-f' => \$file_list,
		'--no-header' => sub { $no_header = 1; },
	};
	my @in_files = ();
	parse_args($cmd, \@args, \&print_usage_merge, $opts, [], \@in_files);

	if ($file_list ne '') {
		$file_list = $STDIN if $file_list eq '-';
		open my $fh, "<", $file_list or die "Error: Can not open file '$ARGV[0]'";
		while (my $line = <$fh>) {
			chomp $line;
			$line =~ s/(^\s*|\s*$)//g;
			next if $line eq '' or $line =~ /^#/;
			die "Error: File '$line' does not exist" unless -e $line;
			push @in_files, $line;
		}
		close $fh;
	}
	if (scalar(@in_files) == 1 and not -t STDIN and $file_list ne $STDIN) {
		unshift @in_files, $STDIN;
	}
	print_usage_merge($cmd, $opts) if scalar(@in_files) < 2;

	my $d = load_tsv($in_files[0], $no_header, $sep);
	for my $i (1 .. $#in_files) {
		$d = merge_tsv($d, load_tsv($in_files[$i], $no_header, $sep));
	}
	write_tsv($d, $STDOUT);
	exit 0;
}

sub do_join
{
	my ($cmd, @args) = @_;

	my ($in_file_1, $in_file_2, $no_header, $out_file, $sep, $join_type) = ('', '', 0, $STDOUT, "\t", 'inner');
	my @by_cols = ();
	my $opts = {
		'-o' => \$out_file,
		'-s' => \$sep,
		'--no-header' => sub { $no_header = 1; },
		'-t' => \$join_type,
	};
	parse_args($cmd, \@args, \&print_usage_join, $opts, [ \$in_file_1, \$in_file_2 ], \@by_cols);

	if ($in_file_2 eq '') {
		print_usage_join($cmd, $opts) if -t STDIN;
		($in_file_1, $in_file_2) = ($STDIN, $in_file_1);
	}
	print_usage_join($cmd, $opts) unless $in_file_1 ne '' and $in_file_2 ne '';

	my %valid_join_types = map { $_ => 1 } ('inner', 'left', 'right', 'full');
	die "Error: Invalid join type '$join_type'" unless exists $valid_join_types{$join_type};

	my $d1 = load_tsv($in_file_1, $no_header, $sep);
	my $d2 = load_tsv($in_file_2, $no_header, $sep);
	my %names1 = map { $_ => 1 } @{$d1->{names}};
	my %names2 = map { $_ => 1 } @{$d2->{names}};
	my @keys = ();
	if (not @by_cols) {
		for my $name (@{$d1->{names}}) {
			push @keys, { left => $name, right => $name } if exists $names2{$name};
		}
		die "Error: No shared column found between '$in_file_1' and '$in_file_2'" if not @keys;
	} else {
		for my $x (@by_cols) {
			if (exists $names1{$x}) {
				die "Error: File '$in_file_2' has not column '$x'" unless exists $names2{$x};
				push @keys, { left => $x, right => $x };
			} else {
				die "Error: Invalid condition '$x'" if $x !~ /^(.+)==?(.+)$/;
				my ($a, $op, $b) = ($1, $2, $3);
				$a =~ s/(^\s*|\s*$)//g;
				$b =~ s/(^\s*|\s*$)//g;
				die "Error: File '$in_file_1' has not column '$a'" unless exists $names1{$a};
				die "Error: File '$in_file_2' has not column '$b'" unless exists $names2{$b};
				push @keys, { left => $a, right => $b };
			}
		}
	}
	my $d = join_tsv($d1, $d2, \@keys, $join_type);
	write_tsv($d, $out_file);
	exit 0;
}

sub do_summary
{
	my ($cmd, @args) = @_;

	my ($in_file, $no_header, $out_file, $sep) = ('', 0, $STDOUT, "\t");
	my $opts = {
		'-o' => \$out_file,
		'-s' => \$sep,
		'--no-header' => sub { $no_header = 1; },
	};
	my @columns = ();
	parse_args($cmd, \@args, \&print_usage_summary, $opts, [ \$in_file ], \@columns);

	if ($in_file eq '') {
		print_usage_summary($cmd, $opts) if -t STDIN;
		$in_file = $STDIN;
	}

	my $d = load_tsv($in_file, $no_header, $sep);
	my $ret = {
		names => [ "number", "colname", "type",
			"count", "na_count",
			"min", "q1", "median", "mean", "q3", "max" ],
		data => [
			map {
				my $name = $d->{names}->[$_];
				my $type = 'number';
				my $count = 0;
				my $na_count = 0;
				for my $item (@{$d->{data}}) {
					++$count;
					++$na_count if ($item->{$name} // '') eq '';
					$type = 'string' if not is_numeric($item->{$name});
				}
				my $item = {
					number => $_ + 1, colname => $name, type => $type,
					count => $count, na_count => $na_count,
				};
				if ($type eq 'number') {
					my @values = sort { $a <=> $b } map { $_->{$name} } @{$d->{data}};
					$item->{min} = $values[0];
					$item->{q1} = quantile(\@values, .25);
					$item->{median} = quantile(\@values, .5);
					$item->{mean} = mean(\@values);
					$item->{q3} = quantile(\@values, .75);
					$item->{max} = $values[$#values];
				}
				$item;
			} (0 .. $#{$d->{names}}) ],
	};
	write_tsv($ret, $out_file);
	exit 0;
}

sub do_to_csv
{
	my ($cmd, @args) = @_;

	my ($in_file, $no_header, $out_file, $sep) = ('', 0, $STDOUT, "\t");
	my $opts = {
		'-o' => \$out_file,
		'-s' => \$sep,
		'--no-header' => sub { $no_header = 1; },
	};
	parse_args($cmd, \@args, \&print_usage_to_csv, $opts, [ \$in_file ]);

	if ($in_file eq '') {
		print_usage_to_csv($cmd, $opts) if -t STDIN;
		$in_file = $STDIN;
	}

	my $d = load_tsv($in_file, $no_header, $sep);
	write_tsv($d, $out_file, { sep => ',' });
	exit 0;
}

sub do_to_xlsx
{
	eval("use Encode");
	die "Error: Perl module 'Encode' should be installed!" if $@;
	eval("use Excel::Writer::XLSX");
	die "Error: Perl module 'Excel::Writer::XLSX' should be installed!" if $@;

	my ($cmd, @args) = @_;

	my ($no_header, $out_file, $sep) = (0, '', "\t");
	my @in_files = ();
	my $opts = {
		'-s' => \$sep,
		'--no-header' => sub { $no_header = 1; },
	};
	parse_args($cmd, \@args, \&print_usage_to_xlsx, $opts, [ \$out_file ], \@in_files);

	if (not @in_files) {
		print_usage_to_xlsx($cmd, $opts) if -t STDIN;
		push @in_files, $STDIN;
	}

	if (-e $out_file and $out_file !~ /\.xlsx$/) {
		print "Warning: output Excel filename should be the first parameter!\n";
		exit 1;
	}
	my $xlsx = Excel::Writer::XLSX->new($out_file);

	for my $arg (@in_files) {
		my $in_tsv = $arg;
		my $name;
		if (not -e $in_tsv and $arg =~ /^(.+)=(.+)$/) {
			($name, $in_tsv) = ($1, $2);
		} else {
			$name = $in_tsv;
			$name =~ s/^.*\///g;
			$name =~ s/\.[^\.]+$//;
		}
		my $worksheet = $xlsx->add_worksheet(decode("utf8", $name));
		$worksheet->add_write_handler(qr[\w], \&store_string_widths);

		my $d = load_tsv($in_tsv);

		my $format = $xlsx->add_format( bold => 1, bg_color => '#dddddd', align => 'center', border => 1 );
		my ($row, $col) = (0, 0);
		for my $name (@{$d->{names}}) {
			$worksheet->write($row, $col++, decode("utf8", $name), $format);
		}

		$worksheet->freeze_panes(1, 0); # Freeze the first row
		$format = $xlsx->add_format( border => 1 );
		for my $item (@{$d->{data}}) {
			$row++;
			$col = 0;
			for my $name (@{$d->{names}}) {
				$worksheet->write($row, $col++, decode("utf8", $item->{$name}), $format);
			}
		}
		autofit_columns($worksheet);
	}
}

sub do_version
{
	print get_version_string(), "\n";
	exit 0;
}

sub do_install
{
	my $dir = dirname($0);
	for my $cmd (sort keys %{$dispatcher}) {
		my $name = $dir . $APPNAME . '-' . $cmd;
		unless (-e $name) {
			symlink $APPNAME, $name or die "Error: Can not create symbolic link '$name'!";
			print STDERR "Symbolic link '$name' created.\n";
		}
	}
	print STDERR "All symbolic links are created.\n";
	my @libs = (
		{ name => 'Encode',              required_for => 'writing Excel files' },
		{ name => 'Excel::Writer::XLSX', required_for => 'writing Excel files' },
		{ name => 'Spreadsheet::XLSX',   required_for => 'reading Excel files' },
	);
	for my $item (@libs) {
		eval("use $item->{name}");
		print STDERR "Warning: Perl module '$item->{name}' is required for $item->{required_for}\n" if $@;
	}
	exit 0;
}

sub do_test
{
	my ($total, $ok, $failed) = (0, 0, 0);
	chdir(dirname($0));
	foreach my $script (glob("test/*.sh")) {
		print STDERR "$script\n";
		open my $fh, "-|", $script or die "Error: Can not execute script '$script'!";
		while (my $line = <$fh>) {
			if ($line =~ /^OK/) {
				$total++;
				$ok++;
			} elsif ($line =~ /^Failed/) {
				$total++;
				$failed++;
			}
			print ". $line" if $verbose;
		}
		close $fh;
	}
	print STDERR "Total $total test(s), $ok passed and $failed failed.\n";
	exit 0;
}
