#!/usr/bin/perl -w
use strict;
use warnings;
use Data::Dumper;

############################################################
# global variables

my $APPNAME = 'tsv';
my $VERSION = "0.1.200124-dev";

my $STDIN = '/dev/stdin';
my $STDOUT = '/dev/stdout';

my $dispatcher = {
	"cat"       => \&do_cat,
	"align"     => \&do_align,
	"view"      => \&do_tsv_view,
	"column"    => \&do_column,
	"transpose" => \&do_tsv_transpose,
	"select"    => \&do_tsv_select,
	"subset"    => \&do_tsv_subset,
	"head"      => \&do_tsv_head,
	"tail"      => \&do_tsv_tail,
	"filter"    => \&do_tsv_filter,
	"cleanup"   => \&do_cleanup,
	"sort"      => \&do_tsv_sort,
	"merge"     => \&do_tsv_merge,
	"join"      => \&do_tsv_join,
	"summary"   => \&do_tsv_summary,
	"to-excel"  => \&do_tsv_to_excel,
	"version"   => \&do_version,
};

my $verbose = 0;

#----------------------------------------------------------#
# main program starts from here

my ($cmd_prefix, $cmd) = ($APPNAME, basename($0));
die "Error: Unexpected command name '$cmd'" if $cmd !~ /^$APPNAME(-|$)/;
if ($cmd eq $APPNAME) {
	print_usage() unless @ARGV;
	$cmd = shift @ARGV;
	$cmd_prefix .= ' ';
} else {
	$cmd =~ s/^$APPNAME-//;
	$cmd_prefix .= '-';
}
do_install() if $cmd eq 'install';
do_test() if $cmd eq 'test';
print_usage() if $cmd eq 'help';
die "Error: Unknown command '$cmd'" unless exists $dispatcher->{$cmd};
exit $dispatcher->{$cmd}->($cmd, @ARGV);

############################################################
# global helper functions

sub basename { my $s = shift; $s =~ s/^.*[\/\\]//; return $s; }
sub dirname  { my $s = shift; $s =~ s/[^\/\\]*$//; return $s; }

############################################################
# args processing

sub fetch_arg
{
	my ($opts, $name) = @_;
	die "Error: Missing option name '$name'" if not exists $opts->{$name};
	return ${$opts->{$name}} // '';
}

sub parse_args
{
	my ($cmd, $args, $func_usage, $func_opts, $vars) = @_;
	my $i = 0;
	while (my $arg = shift @{$args}) {
		if ($arg =~ /^-/) {
			if ($arg eq '-h' or $arg eq '--help') {
				$func_usage->($cmd, $func_opts);
			} elsif ($arg eq '-v' or $arg eq '--verbose') {
				++$verbose;
			} elsif (exists $func_opts->{$arg}) {
				for (;;) {
					my $type = ref($func_opts->{$arg});
					if ($type eq 'CODE') {
						$func_opts->{$arg}->($arg, $args);
						last;
					} elsif ($type eq 'SCALAR') {
						die "Error: Missing option for '$arg'" if not @{$args};
						${$func_opts->{$arg}} = shift @{$args};
						last;
					} else {
						my $s = $func_opts->{$arg};
						die "Error: Option should not point to itself" if $s eq $arg; 
						die "Error: Unexpected value '$s'" if exists $func_opts->{$s};
						$arg = $s;
					}
				}
			} else {
				die "Error: Unknown option '$arg'";
			}
		} else {
			if ($i < scalar(@{$vars})) {
				${$vars->[$i++]} = $arg;
			} else {
				die "Error: Unexpected parameter '$arg'";
			}
		}
	}
}

############################################################
# version & usages

sub get_version_string
{
	chomp(my $hashcode = `md5sum $0`);
	my $version_suffix = '';
	if ($hashcode ne '') {
		$version_suffix = " (" . substr($hashcode, 0, 7) . ")";
	}
	return "$VERSION$version_suffix";
}

sub print_usage
{
	print '
Program: Toolkits for TSV (TAB-Separated Values) File
Version: ' . get_version_string() . '
Author : Linlin Yan <yanlinlin82@gmail.com>
License: MIT 2019-2020

Usage: ' . $APPNAME . ' <command> [options]

Commands:
  - Displaying
      cat        show file content
      align      align columns
      view       view file content in pretty better format
      column     list columns
      transpose  matrix transpose

  - Selecting
      select     select columns
      subset     select rows (subset)
      head       fetch head n rows
      tail       fetch tail n rows
      filter     filter by conditions
      cleanup    remove empty rows or columns

  - Manipulating
      sort       sort by column(s)
      merge      merge multiple files
      join       join two tables by key column(s)
      summary    summary each column

  - Writing
      to-excel   write to Excel (.xlsx) file

  - Others
      version    show program version

';
	exit 1;
}

sub do_version
{
	print get_version_string(), "\n";
	exit 0;
}

sub print_usage_align
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt>

Options:
   -o <FILE>           Output file, default: " . fetch_arg($opts, '-o') . "
   --no-header         Input file does not have header line
   --max-width <int>   Maximum column width for each column, default: " . fetch_arg($opts, '--max-width') . "
   --max-check <int>   Maximum checking lines for calculate column width, default: " . fetch_arg($opts, '--max-check') . "

";
	exit 1;
}

sub print_usage_cat
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt>

Options:
   -o <FILE>     Output file, default: " . fetch_arg($opts, '-o') . "
   --no-header   Input file does not have header line

";
	exit 1;
}

sub print_usage_cleanup
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt>

Options:
   -o <FILE>     Output file, default: " . fetch_arg($opts, '-o') . "
   --no-header   Input file does not have header line

";
	exit 1;
}

sub print_usage_column
{
	my ($cmd, $opts) = @_;
	print "
Usage: $cmd_prefix$cmd [options] <in.txt>

Options:
   -o <FILE>     Output file, default: " . fetch_arg($opts, '-o') . "
   --no-header   Input file does not have header line

";
	exit 1;
}

############################################################
# data frame manipulating

sub df_get_names { my $d = shift; return @{$d->{names}}; }

############################################################
# commands

sub do_align
{
	my ($cmd, @args) = @_;

	my ($in_file, $no_header, $out_file) = ('', 0, $STDOUT);
	my $max_align_column_width = 100;
	my $max_align_check_lines = 1000;
	my $opts = {
		'--no-header' => sub { $no_header = 1; },
		'--max-width' => \$max_align_column_width,
		'--max-check' => \$max_align_check_lines,
		'-o' => \$out_file
	};
	parse_args($cmd, \@args, \&print_usage_align, $opts, [ \$in_file ]);

	if ($in_file eq '') {
		print_usage_align($cmd, $opts) if -t STDIN;
		$in_file = $STDIN;
	}
	my $d = load_tsv($in_file, $no_header);
	my %width = map { $_ => ($no_header ? 0 : get_text_width($_)) } @{$d->{names}};
	my $counter = 0;
	for my $item (@{$d->{data}}) {
		for my $name (@{$d->{names}}) {
			if ($width{$name} < $max_align_column_width) {
				my $width = get_text_width($item->{$name});
				$width = $max_align_column_width if $width > $max_align_column_width;
				$width{$name} = $width if $width{$name} < $width;
			}
		}
		last if ++$counter >= $max_align_check_lines;
	}
	open my $ofh, '>', $out_file or die "Error: Can not create file '$out_file'";
	if (not $no_header) {
		print $ofh join("  ", map { align_text($_, $width{$_}) } @{$d->{names}}), "\n";
	}
	for my $item (@{$d->{data}}) {
		print $ofh join("  ", map { align_text($item->{$_}, $width{$_}) } @{$d->{names}}), "\n";
	}
	close $ofh;
	exit 0;
}

sub do_cat
{
	my ($cmd, @args) = @_;

	my ($in_file, $no_header, $out_file) = ('', 0, $STDOUT);
	my $opts = {
		'--no-header' => sub { $no_header = 1; },
		'-o' => \$out_file
	};
	parse_args($cmd, \@args, \&print_usage_cat, $opts, [ \$in_file ]);

	if ($in_file eq '') {
		print_usage_cat($cmd, $opts) if -t STDIN;
		$in_file = $STDIN;
	}
	my $d = load_tsv($in_file, $no_header);
	write_tsv($d, $out_file);
	exit 0;
}

sub do_cleanup
{
	my ($cmd, @args) = @_;

	my ($in_file, $no_header, $out_file) = ('', 0, $STDOUT);
	my $opts = {
		'--no-header' => sub { $no_header = 1; },
		'-o' => \$out_file
	};
	parse_args($cmd, \@args, \&print_usage_cleanup, $opts, [ \$in_file ]);

	if ($in_file eq '') {
		print_usage_cleanup($cmd, $opts) if -t STDIN;
		$in_file = $STDIN;
	}
	my $d = load_tsv($in_file, $no_header);
	@{$d->{names}} = grep {
			my $x = 0;
			for my $item (@{$d->{data}}) {
				if ($item->{$_} // '') { $x = 1; last; }
			}
			$x;
		} df_get_names($d);
	@{$d->{data}} = grep {
			my $x = 0;
			for my $name (df_get_names($d)) {
				if ($_->{$name} // '') { $x = 1; last; }
			}
			$x;
		} @{$d->{data}};
	write_tsv($d);
	exit 0;
}

sub do_column
{
	my ($cmd, @args) = @_;

	my ($in_file, $no_header, $out_file) = ('', 0, $STDOUT);
	my $opts = {
		'--no-header' => sub { $no_header = 1; },
		'-o' => \$out_file
	};
	parse_args($cmd, \@args, \&print_usage_column, $opts, [ \$in_file ]);

	if ($in_file eq '') {
		print_usage_column($cmd, $opts) if -t STDIN;
		$in_file = $STDIN;
	}
	my $d = load_tsv($in_file, $no_header);
	my $column = {
		names => [ "number", "colname" ],
		data => [ map { {
				number => $_ + 1,
				colname => $d->{names}->[$_]
			} } (0 .. $#{$d->{names}}) ]
	};
	write_tsv($column);
	exit 0;
}

sub do_tsv_view
{
	my $in_file;
	if (scalar(@ARGV) >= 1) {
		$in_file = shift @ARGV;
	} elsif (not -t STDIN) {
		$in_file = $STDIN;
	} else {
		print "Usage: $cmd_prefix$cmd <in.txt>\n";
		exit 1;
	}
	my $d = load_tsv($in_file);
	view_tsv($d);
	exit 0;
}

sub tsv_get_column_count
{
	my $d = shift @_;
	return scalar(df_get_names($d));
}

sub tsv_get_names
{
	my $d = shift @_;
	return $d->{names};
}

sub tsv_fetch_row
{
	my $d = shift @_;
	$d->{current_row} = 0 unless exists $d->{current_row};
	if ($d->{current_row} <= $#{$d->{data}}) {
		return $d->{data}->[$d->{current_row}++];
	}
	return undef;
}

sub tsv_sort
{
	my ($d, $column_count) = @_;
	my $max_column_count = tsv_get_column_count($d);
	$column_count = 1 if $column_count < 1;
	$column_count = $max_column_count if $column_count > $max_column_count;
	my $column = $d->{names}->[$column_count - 1];
	@{$d->{data}} = sort { ($a->{$column} // '') cmp ($b->{$column} // '') } @{$d->{data}};
}

sub do_tsv_sort
{
	my ($in_file, $column_count);
	if (scalar(@ARGV) >= 2) {
		($in_file, $column_count) = @ARGV;
	} elsif (scalar(@ARGV) == 1) {
		if (not -t STDIN) {
			($in_file, $column_count) = ($STDIN, $ARGV[0]);
		} else {
			($in_file, $column_count) = ($ARGV[0], 1);
		}
	} else {
		if (-t STDIN) {
			print "Usage: $cmd_prefix$cmd <in.txt> [column_count]\n";
			exit 1;
		}
		($in_file, $column_count) = ($STDIN, 1);
	}
	my $d = load_tsv($in_file);
	tsv_sort($d, $column_count);
	write_tsv($d);
	exit 0;
}

sub do_tsv_merge
{
	if (scalar @ARGV < 2) {
		print "Usage: $cmd_prefix$cmd <in_1.txt> <in_2.txt>...\n";
		print "       $cmd_prefix$cmd -f <file-list.txt>\n";
		exit 1;
	}
	my @in_files;
	if ($ARGV[0] ne "-f") {
		@in_files = @ARGV;
	} else {
		shift @ARGV;
		die "Error: Missing parameter after '-f'" unless @ARGV;
		open my $fh, "<", ($ARGV[0] eq "-" ? $STDIN : $ARGV[0]) or die "Error: Can not open file '$ARGV[0]'";
		@in_files = map { chomp; $_ } <$fh>;
		close $fh;
	}
	my $d = load_tsv(shift @in_files);
	while (my $filename = shift @in_files) {
		$d = merge_tsv($d, load_tsv($filename));
	}
	write_tsv($d);
	exit 0;
}

sub do_tsv_head
{
	my ($in_file, $num, $sign);
	if (scalar(@ARGV) >= 2) {
		($in_file, $num) = @ARGV;
	} elsif (scalar(@ARGV) == 1) {
		if (not -t STDIN) {
			($in_file, $num) = ($STDIN, $ARGV[0]);
		} else {
			($in_file, $num) = ($ARGV[0], 10);
		}
	} else {
		if (-t STDIN) {
			print "Usage: $cmd_prefix$cmd <in.txt> [NUM]\n";
			print "Note:\n";
			print "  1. 'NUM' should be an integer number (defaults to 10), print the first NUM lines\n";
			print "  2. if 'NUM' is leading with '-', print all but the last NUM lines\n";
			exit 1;
		}
		($in_file, $num) = ($STDIN, 10);
	}
	die "Error: Invalid NUM value '$num'" unless $num =~ /^([-+]?)([0-9][0-9]*)$/;
	($sign, $num) = ($1, $2);
	my $d = load_tsv($in_file);
	my $max_num = scalar @{$d->{data}};
	$num = $max_num if $num > $max_num;
	if ($sign eq "-") {
		@{$d->{data}} = @{$d->{data}}[0 .. ($max_num - $num - 1)];
	} else {
		@{$d->{data}} = @{$d->{data}}[0 .. ($num - 1)];
	}
	write_tsv($d);
	exit 0;
}

sub prepare_join_header
{
	my ($tsv1, $tsv2, $column) = @_;
	my %h1 = map { $tsv1->{names}->[$_] => $_ } (0 .. $#{$tsv1->{names}});
	my %h2 = map { $tsv2->{names}->[$_] => $_ } (0 .. $#{$tsv2->{names}});
	die "Error: column '$column' does not exist in left table" unless exists $h1{$column};
	die "Error: column '$column' does not exist in right table" unless exists $h2{$column};
	my @header = ();
	push @header, { TSV => "left", name => $column, index => $column };
	for my $name (@{$tsv1->{names}}) {
		if ($name ne $column) {
			push @header, {
				TSV => "left",
				name => $name . (exists $h2{$name} ? ".x" : ''),
				index => $name
			};
		}
	}
	for my $name (@{$tsv2->{names}}) {
		if ($name ne $column) {
			push @header, {
				TSV => "right",
				name => $name . (exists $h1{$name} ? ".y" : ''),
				index => $name
			};
		}
	}
	return \@header;
}

sub prepare_join_hash
{
	my ($d, $column) = @_;
	my @values = ();
	my %hash = ();
	for my $i (0 .. $#{$d->{data}}) {
		my $item = $d->{data}->[$i];
		my $key = $item->{$column};
		if (not exists $hash{$key}) {
			push @values, $key;
			$hash{$key} = [ $i ];
		} else {
			push @{$hash{$key}}, $i;
		}
	}
	return { values => \@values, hash => \%hash };
}

sub join_merge_item
{
	my ($item1, $item2, $header) = @_;
	my %hash = ();
	for my $h (@{$header}) {
		my ($d, $name, $index) = map { $h->{$_} } ("TSV", "name", "index");
		if ($d eq "left") {
			$hash{$name} = $item1->{$index};
		} else {
			$hash{$name} = $item2->{$index};
		}
	}
	return \%hash;
}

sub join_tsv
{
	my ($tsv1, $tsv2, $column) = @_;
	my $header = prepare_join_header($tsv1, $tsv2, $column);
	my $h1 = prepare_join_hash($tsv1, $column);
	my $h2 = prepare_join_hash($tsv2, $column);
	my @data = ();
	for my $value (@{$h1->{values}}) {
		next if not exists $h2->{hash}->{$value};
		for my $i (@{$h1->{hash}->{$value}}) {
			for my $j (@{$h2->{hash}->{$value}}) {
				push @data, join_merge_item($tsv1->{data}->[$i], $tsv2->{data}->[$j], $header);
			}
		}
	}
	return {
		names => [ map { $_->{name} } @{$header} ],
		data => \@data
	};
}

sub do_tsv_join
{
	my ($left_file, $right_file, $column);
	if (scalar(@ARGV) >= 3) {
		($left_file, $right_file, $column) = @ARGV;
	} elsif (scalar(@ARGV) == 2 and not -t STDIN) {
		($left_file, $right_file, $column) = ($STDIN, @ARGV);
	} else {
		print "Usage: $cmd_prefix$cmd <in-left.txt> <in-right.txt> <column>\n";
		exit 1;
	}
	my $tsv1 = load_tsv($left_file);
	my $tsv2 = load_tsv($right_file);
	my $d = join_tsv($tsv1, $tsv2, $column);
	write_tsv($d);
	exit 0;
}

sub do_tsv_tail
{
	my ($in_file, $num, $sign);
	if (scalar(@ARGV) >= 2) {
		($in_file, $num) = @ARGV;
	} elsif (scalar(@ARGV) == 1) {
		if (not -t STDIN) {
			($in_file, $num) = ($STDIN, $ARGV[0]);
		} else {
			($in_file, $num) = ($ARGV[0], 10);
		}
	} else {
		if (-t STDIN) {
			print "Usage: $cmd_prefix$cmd <in.txt> [NUM]\n";
			print "Note:\n";
			print "  1. 'NUM' should be an integer number (defaults to 10), print the last NUM lines\n";
			print "  2. if 'NUM' is leading with '+', print lines starting with line NUM\n";
			exit 1;
		}
		($in_file, $num) = ($STDIN, 10);
	}
	die "Error: Invalid NUM value '$num'" unless $num =~ /^([-+]?)([0-9][0-9]*)$/;
	($sign, $num) = ($1, $2);
	my $d = load_tsv($in_file);
	my $max_num = scalar(@{$d->{data}});
	$num = $max_num if $num > $max_num;
	if ($sign eq "+") {
		@{$d->{data}} = @{$d->{data}}[($num - 1) .. ($max_num - 1)];
	} else {
		@{$d->{data}} = @{$d->{data}}[($max_num - $num) .. ($max_num - 1)];
	}
	write_tsv($d);
	exit 0;
}

sub do_tsv_select
{
	my ($in_file, $fields);
	if (scalar(@ARGV) >= 2) {
		($in_file, $fields) = @ARGV;
	} elsif (scalar(@ARGV) == 1 and not -t STDIN) {
		($in_file, $fields) = ($STDIN, $ARGV[0]);
	} else {
		print "Usage: $cmd_prefix$cmd <in.txt> <FIELD1,FIELD2,...>\n";
		exit 1;
	}
	my $d = load_tsv($in_file);
	my %colname = map { $_ => 1 } df_get_names($d);
	my @names = ();
	for my $name (split(",", $fields)) {
		if ($name =~ /^([0-9][0-9]*)$/) {
			my $i = $1;
			die "Error: Unexpected column count '$i'" if $i < 1 or $i > scalar(df_get_names($d));
			$name = $d->{names}->[$i - 1];
		} else {
			die "Error: Unexpected column name '$name'" unless exists $colname{$name};
		}
		push @names, $name;
	}
	write_tsv($d, "/dev/stdout", "\t", \@names);
	exit 0;
}

sub do_tsv_subset
{
	my ($in_file, $rows);
	if (scalar(@ARGV) >= 2) {
		($in_file, $rows) = @ARGV;
	} elsif (scalar(@ARGV) == 1 and not -t STDIN) {
		($in_file, $rows) = ($STDIN, $ARGV[0]);
	} else {
		print "Usage: $cmd_prefix$cmd <in.txt> <ROWS1,ROW2,...>\n";
		exit 1;
	}
	my $d = load_tsv($in_file);
	my @rows = ();
	for my $row (split(",", $rows)) {
		if ($row =~ /^([0-9][0-9]*)$/) {
			if ($row >= 1 and $row <= scalar(@{$d->{data}})) {
				push @rows, $row - 1;
			}
		} else {
			die "Error: Unexpected row count '$row'";
		}
	}
	@{$d->{data}} = @{$d->{data}}[@rows];
	write_tsv($d);
	exit 0;
}

sub is_numeric
{
	my $val = shift @_;
	return do { no warnings; $val eq ($val + 0) };
}

sub parse_cond
{
	my ($cond, $item) = @_;
	#print "parse_cond('$cond', { " . join(", ", map { "$_ => $item->{$_}" } sort(keys(%{$item}))) . " })\n";
	for my $name (keys %{$item}) {
		if (is_numeric($item->{$name})) {
			$cond =~ s/\b$name\b/$item->{$name}/g;
		} else {
			$cond =~ s/\b$name\b/"$item->{$name}"/g;
		}
	}
	#print " cond = '$cond'\n";
	my $val = do { no warnings; eval($cond) };
	#print " val = '$val'\n";
	return $val;
}

sub do_tsv_filter
{
	my ($in_file, $cond);
	if (scalar(@ARGV) >= 2) {
		($in_file, $cond) = @ARGV;
	} elsif (scalar(@ARGV) == 1 and not -t STDIN) {
		($in_file, $cond) = ($STDIN, $ARGV[0]);
	} else {
		print "Usage: $cmd_prefix$cmd <in.txt> <condition>\n";
		exit 1;
	}
	my $d = load_tsv($in_file);
	my $row_count = scalar(@{$d->{data}});
	my @data = ();
	for my $item (@{$d->{data}}) {
		push @data, $item if parse_cond($cond, $item);
	}
	@{$d->{data}} = @data;
	write_tsv($d);
	exit 0;
}

sub print_usage_transpose
{
	print "
Usage: $cmd_prefix$cmd [options] <in.txt>

Options:
   --no-header   Input file does not have header line

";
	exit 1;
}

sub do_tsv_transpose
{
	my $in_file = '';
	my $no_header = 0;
	while (my $arg = shift @ARGV) {
		if ($arg =~ /^-/) {
			if ($arg eq '-h' or $arg eq '--help') {
				print_usage_transpose();
			} elsif ($arg eq '--no-header') {
				$no_header = 1;
			} else {
				die "Error: Unknown option '$arg' for '$cmd_prefix$cmd'";
			}
		} elsif ($in_file eq '') {
			$in_file = $arg;
		} else {
			die "Error: Unexpected parameter '$arg' for '$cmd_prefix$cmd'";
		}
	}
	if ($in_file eq '') {
		if (-t STDIN) {
			print_usage_align();
		} else {
			$in_file = $STDIN;
		}
	}
	my $d = load_tsv($in_file, $no_header);
	my $res = {
		names => [ "colname", map { "row_" . ($_ + 1) } (0 .. $#{$d->{data}}) ],
		data => [ map {
				my $name = $_;
				{
					"colname" => $name,
					map { "row_" . ($_ + 1) => $d->{data}->[$_]->{$name} } (0 .. $#{$d->{data}})
				}
			} df_get_names($d) ]
	};
	write_tsv($res);
	exit 0;
}

sub view_tsv
{
	my $d = shift @_;
	my $max_name_width = 0;
	my $names = tsv_get_names($d);
	my $id_width = get_text_width(scalar(@{$names}) - 1);
	my $max_id_width = ($id_width >= length('id') ? $id_width : length('id'));
	for my $name (@{$names}) {
		my $width = get_text_width($name);
		$max_name_width = $width if $max_name_width < $width;
	}
	my $row = 0;
	while (my $item = tsv_fetch_row($d)) {
		print "# row " . ++$row . "\n";
		print join("  ",
			align_text('id', $max_id_width),
			align_text('column', $max_name_width),
			'value'), "\n";
		my $column_id = 0;
		for my $name (@{$names}) {
			print join("  ",
				align_text(++$column_id, $max_id_width),
				align_text($name, $max_name_width),
				$item->{$name}), "\n";
		}
		print "\n";
	}
	exit 0;
}

sub do_tsv_to_excel
{
	eval("use Encode");
	die "Error: Perl module 'Encode' should be installed!" if $@;
	eval("use Excel::Writer::XLSX");
	die "Error: Perl module 'Excel::Writer::XLSX' should be installed!" if $@;

	if (scalar @ARGV < 2) {
		print "Usage: $cmd_prefix$cmd <out.xlsx> <in.tsv>...\n";
		exit 1;
	}
	my $out_xlsx = shift @ARGV;
	if (-e $out_xlsx and $out_xlsx !~ /\.xlsx$/) {
		print "Warning: output Excel filename should be the first parameter!\n";
		exit 1;
	}
	my $excel = Excel::Writer::XLSX->new($out_xlsx);

	for my $arg (@ARGV) {
		my $in_tsv = $arg;
		my $name;
		if (not -e $in_tsv and $arg =~ /^(.+)=(.+)$/) {
			($name, $in_tsv) = ($1, $2);
		} else {
			$name = $in_tsv;
			$name =~ s/^.*\///g;
			$name =~ s/\.[^\.]+$//;
		}
		my $worksheet = $excel->add_worksheet(decode("utf8", $name));
		$worksheet->add_write_handler(qr[\w], \&store_string_widths);

		my $d = load_tsv($in_tsv);

		my $format = $excel->add_format( bold => 1, bg_color => '#dddddd', align => 'center', border => 1 );
		my ($row, $col) = (0, 0);
		for my $name (df_get_names($d)) {
			$worksheet->write($row, $col++, decode("utf8", $name), $format);
		}

		$worksheet->freeze_panes(1, 0); # Freeze the first row
		$format = $excel->add_format( border => 1 );
		for my $item (@{$d->{data}}) {
			$row++;
			$col = 0;
			for my $name (df_get_names($d)) {
				$worksheet->write($row, $col++, decode("utf8", $item->{$name}), $format);
			}
		}
		autofit_columns($worksheet);
	}
}

sub get_unique_name
{
	my ($name, $hash) = @_;
	$name =~ s/(^\s*|\s*$)//g;
	while ($name eq '' or exists $hash->{$name}) {
		if ($name =~ /^(.*)_([0-9]*)$/) {
			$name = $1 . "_" . (($2 // 0) + 1);
		} else {
			$name .= "_1";
		}
	}
	$hash->{$name} = 1;
	return $name;
}

sub fetch_xlsx_row
{
	my ($sheet, $row) = @_;
	my @values = ();
	my %decode = ( amp => "&", lt => "<", gt => ">", "quot" => "\"", "nbsp" => " " );
	for my $col ($sheet->{MinCol} .. $sheet->{MaxCol}) {
		my $cell = $sheet->{Cells}[$row][$col];
		my $value = ((not defined $cell) ? '' : ($cell->{Val} // ''));
		$value =~ s{&([a-z]+);}{$decode{$1}//$1}gex;
		$value =~ s/[\t\n\r]/ /gm;
		push @values, $value;
	}
	return @values;
}

sub prepare_colnames
{
	my ($names, $hash) = @_;
	return map {
		my ($original_name, $name) = ($_, $_);
		$name = "_" . $name if $name =~ /^[0-9]/;
		$name = get_unique_name($name, $hash);
		#print STDERR "Note: Column '$original_name' renamed to '$name'\n" if $original_name ne $name;
		$name;
	} @{$names};
}

sub load_xlsx
{
	eval("use Spreadsheet::XLSX");
	die "Error: Perl module 'Spreadsheet::XLSX' should be installed!" if $@;

	my ($filename, $no_header) = @_;
	my %sheet_no = ();
	if ($filename =~ /^(.+):([0-9,]+)$/) {
		$filename = $1;
		%sheet_no = map { $_ => 1 } (split(",", $2));
	}
	$sheet_no{1} = 1 unless %sheet_no; # load only the first sheet by default

	my $excel = Spreadsheet::XLSX->new($filename);
	if (not defined $excel) {
		print STDERR "Error: Can not open Excel file '$filename'. " . $excel->error() . ".\n";
		exit 1;
	}

	my $counter = 0;
	my $d;
	for my $sheet (@{$excel->{Worksheet}}) {
		my @names = ();
		my %hash = ();
		my @data = ();
		if (exists $sheet_no{0} or exists $sheet_no{++$counter}) {
			for my $row ($sheet->{MinRow} .. $sheet->{MaxRow}) {
				my @values = fetch_xlsx_row($sheet, $row);
				if ($row == $sheet->{MinRow} and not $no_header) {
					@names = prepare_colnames(\@values, \%hash);
				} else {
					if ($#names < $#values) {
						push @names, map { get_unique_name('', \%hash) } (($#names + 1) .. $#values)
					}
					my %item = map { $names[$_] => $values[$_] // '' } (0 .. $#names);
					push @data, \%item;
				}
			}
		}
		my $tsv2 = { names => \@names, data => \@data };
		if (not defined $d) {
			$d = $tsv2;
		} else {
			$d = merge_tsv($d, $tsv2);
		}
	}
	return $d;
}

sub autofit_columns {
	my $worksheet = shift;
	my $col       = 0;
	for my $width (@{$worksheet->{__col_widths}}) {
		$worksheet->set_column($col, $col, $width) if $width;
		$col++;
	}
}

sub store_string_widths {

	my $worksheet = shift;
	my $col       = $_[1];
	my $token     = $_[2];

	# Ignore some tokens that we aren't interested in.
	return if not defined $token;       # Ignore undefs.
	return if $token eq '';             # Ignore blank cells.
	return if ref $token eq 'ARRAY';    # Ignore array refs.
	return if $token =~ /^=/;           # Ignore formula

	# Ignore numbers
	return if $token =~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/;

	# Ignore various internal and external hyperlinks. In a real scenario
	# you may wish to track the length of the optional strings used with
	# urls.
	return if $token =~ m{^[fh]tt?ps?://};
	return if $token =~ m{^mailto:};
	return if $token =~ m{^(?:in|ex)ternal:};

	# We store the string width as data in the Worksheet object. We use
	# a double underscore key name to avoid conflicts with future names.
	#
	my $old_width    = $worksheet->{__col_widths}->[$col];
	my $string_width = string_width($token);

	if (not defined $old_width or $string_width > $old_width) {
		# You may wish to set a minimum column width as follows.
		#return undef if $string_width < 10;

		$worksheet->{__col_widths}->[$col] = $string_width;
	}
	# Return control to write();
	return undef;
}

sub string_width {
	return 0.9 * length($_[0]) + 3;
}

sub open_file
{
	my $filename = shift @_;
	my ($mod, $con) = ("<", $filename);
	die "Error: '$filename' is a directory" if -d $filename;
	if    ($filename eq "-"     ) { $mod = "<";  $con = $STDIN; }
	elsif ($filename =~ /\.gz$/ ) { $mod = "-|"; $con = "zcat '$filename'"; }
	elsif ($filename =~ /\.bz2$/) { $mod = "-|"; $con = "bzcat '$filename'"; }
	elsif ($filename =~ /\.zip$/) { $mod = "-|"; $con = "unzip -p '$filename'"; }
	open my $fh, $mod, $con or die "Error: Can not open file '$filename'";
	return $fh;
}

sub close_file
{
	my $fh = shift @_;
	close $fh;
}

sub load_bed
{
	# Spec: https://genome.ucsc.edu/FAQ/FAQformat.html#format1
	#       https://genome.ucsc.edu/FAQ/FAQformat.html#format1.7
	my $filename = shift @_;
	my $fh = open_file($filename);
	my @names = ("chrom", "chromStart", "chromEnd", "name", "score", "strand",
		"thickStart", "thickEnd", "itemRgb", "blockCount", "blockSizes", "blockStarts");
	my @names2 = (@names[0..2], "id", "desc", @names[3..$#names]);
	my @data = ();
	my $max_column_count = 0;
	my $has_bed_detail = 0;
	my $is_current_bed_detail = 0;
	while (my $line = <$fh>) {
		chomp $line;
		if ($line =~ /^track name=/) {
			if ($line =~ /type=bedDetail/) {
				$has_bed_detail = 1;
				$is_current_bed_detail = 1;
			} else {
				$is_current_bed_detail = 0;
			}
		} else {
			my @values = split("\t", $line, -1);
			die "Error: Unexpected column count" if scalar(@values) > ($is_current_bed_detail ? scalar(@names2) : scalar(@names));
			$max_column_count = scalar(@values) if $max_column_count < scalar(@values);
			my %item = map { ($is_current_bed_detail ? $names2[$_] : $names[$_]) => ($values[$_] // '') } (0 .. $#values);
			push @data, \%item;
		}
	}
	close_file($fh);
	if ($has_bed_detail) {
		@names2 = @names2[0 .. ($max_column_count - 1)];
		return { names => \@names2, data => \@data };
	} else {
		@names = @names[0 .. ($max_column_count - 1)];
		return { names => \@names, data => \@data };
	}
}

sub load_psl
{
	# Spec: https://genome.ucsc.edu/FAQ/FAQformat.html#format2
	my $filename = shift @_;
	my $fh = open_file($filename);
	my @names = ("matches", "misMatches", "repMatches", "nCount",
		"qNumInsert", "qBaseInsert", "tNumInsert", "tBaseInsert", "strand",
		"qName", "qSize", "qStart", "qEnd", "tName", "tSize", "tStart", "tEnd",
		"blockCount", "blockSizes", "qStarts", "tStarts");
	my @data = ();
	my $head_skipped = 1;
	while (my $line = <$fh>) {
		chomp $line;
		if ($fh->input_line_number == 1 and $line =~ /^psLayout/) {
			$head_skipped = 0;
		} elsif (not $head_skipped) {
			$head_skipped = 1 if $line =~ /^[-][-]*$/;
		} else {
			my @values = split("\t", $line, -1);
			die "Error: Unexpected column count" if $#values != $#names;
			my %item = map { $names[$_] => ($values[$_] // '') } (0 .. $#values);
			push @data, \%item;
		}
	}
	close_file($fh);
	return { names => \@names, data => \@data };
}

sub is_valid_xslx_ref
{
	my $filename = shift;
	if ($filename =~ /^(.*\.xlsx)(|:([0-9,]+))$/) {
		if (-e $1) {
			return 1;
		}
	}
	return 0;
}

sub load_tsv
{
	my ($filename, $no_header) = @_;
	my @names = ();
	my @data = ();
	if (defined($filename) and (($filename eq "-" and not -t STDIN) or
			-e $filename or is_valid_xslx_ref($filename))) {
		my ($mod, $con, $sep) = ("<", $filename, "\t");

		$sep = "," if $filename =~ /\.csv(|\.gz|\.bz2)$/;

		if (is_valid_xslx_ref($filename)) { return load_xlsx($filename, $no_header); }
		if ($filename =~ /\.bed(|\.gz|\.bz2)$/) { return load_bed($filename); }
		if ($filename =~ /\.psl(|\.gz|\.bz2)$/) { return load_psl($filename); }
		my $fh = open_file($filename);
		my %hash = ();
		while (my $line = <$fh>) {
			chomp $line;
			if ($fh->input_line_number == 1 and not $no_header) {
				@names = split($sep, $line, -1);
				@names = prepare_colnames(\@names, \%hash);
			} else {
				my @values = split($sep, $line, -1);
				if ($#names < $#values) {
					push @names, map { get_unique_name('', \%hash) } (($#names + 1) .. $#values)
				}
				my %item = map { $names[$_] => ($values[$_] // '') } (0 .. $#names);
				push @data, \%item;
			}
		}
		close_file($fh);
	}
	return { names => \@names, data => \@data };
}

sub write_tsv
{
	my ($d, $out_file, $sep, $names) = @_;
	$sep = "\t" unless defined $sep;
	$names = tsv_get_names($d) unless defined $names;
	open my $fh, ">", ($out_file // "/dev/stdout") or die "Error: Can not write to file '$out_file'";
	print $fh join($sep, @{$names}), "\n";
	while (my $item = tsv_fetch_row($d)) {
		print $fh join($sep, map { $item->{$_} // '' } (@{$names})), "\n";
	}
	close $fh;
}

sub align_text
{
	my ($s, $w) = @_;
	$s = '' unless defined $s;
	if ($w > 0) {
		my $tw = get_text_width($s);
		if ($tw < $w) {
			$s .= (' ' x ($w - $tw));
		} elsif ($tw > $w) {
			$s = trim_text_at_width($s, $w, "...");
		}
	}
	return $s;
}

sub merge_tsv
{
	my ($a, $b) = @_;
	my @names = @{$a->{names}};
	my %hash = map { $_ => 1 } @names;
	for my $name (@{$b->{names}}) {
		push @names, $name unless exists $hash{$name};
		$hash{$name} = 1;
	}
	return { names => \@names, data => [ @{$a->{data}}, @{$b->{data}} ] };
}

sub skip_characters_in_range
{
	my ($s, $offset, $i, $lower, $upper) = @_;
	my $c;
	for (;;) {
		$c = ord(substr($s, $offset + $i, 1));
		last unless $c >= $lower and $c <= $upper;
		++$i;
	}
	return ($i, $c);
}

sub get_character_width
{
	my ($s, $offset) = @_;
	my $c = ord(substr($s, $offset, 1));
	my ($byte_count, $width);
	if ($c == 0x1B) {  # ANSI escape code
		my $c1 = ord(substr($s, $offset + 1, 1));
		if ($c1 == ord('[')) {  # Control Sequence Introducer
			my $i = 2;
			($i, $c1) = skip_characters_in_range($s, $offset, $i, 0x30, 0x3F);
			($i, $c1) = skip_characters_in_range($s, $offset, $i, 0x20, 0x2F);
			die "Unexpected CSI character '" . sprintf("%02X", $c1) . "' at byte offset '" . ($offset + $i) . "' of '$s'!" unless $c1 >= 0x40 and $c1 <= 0x7E;
			$byte_count = $i + 1;
			$width = 0;
		} else {
			die "Unexpected ANSI escape code '" . sprintf("%02X", $c1) . "' at byte offset '$offset' of '$s'!" unless $c1 >= 0x40 and $c1 <= 0x5F;
			$byte_count = 2;
			$width = 0;
		}
	} elsif ($c <= 0x7F) {  # U+0000 ~ U+007F: 0XXXXXXX
		$byte_count = 1;
		$width = 1;
	} elsif ($c <= 0xE0) {  # U+0080 ~ U+07FF: 110XXXXX 10XXXXXX
		$byte_count = 2;
		$width = 2;
	} elsif ($c <= 0xF0) {  # U+0800 ~ U+FFFF: 1110XXXX 10XXXXXX 10XXXXXX
		my ($c1, $c2) = map { ord(substr($s, $offset + $_, 1)) } (1, 2);
		$byte_count = 3;
		$width = (($c == 0xE2 and ($c1 >= 0x84 and $c1 <= 0xB9) and ($c2 >= 0x80 and $c2 <= 0xBF)) ? 1 : 2);
	} elsif ($c <= 0xF8) {  # U+10000 ~ U+1FFFFF: 11110XXXX 10XXXXXX 10XXXXXX 10XXXXXX
		$byte_count = 4;
		$width = 2;
	} elsif ($c <= 0xFC) {  # U+200000 ~ U+3FFFFFF: 11110XXXX 10XXXXXX 10XXXXXX 10XXXXXX 10XXXXXX
		$byte_count = 5;
		$width = 2;
	} elsif ($c <= 0xFE) {  # U+4000000 ~ U+7FFFFFFF: 11110XXXX 10XXXXXX 10XXXXXX 10XXXXXX 10XXXXXX 10XXXXXX
		$byte_count = 6;
		$width = 2;
	} else {
		die "Unexpected UTF8 character '" . sprintf("%02X", $c) . "' at byte offset '$offset' of '$s'!";
	}
	die "Truncated string at byte offset '$offset' of '$s'!" if $offset + $byte_count > length($s);
	return ($byte_count, $width);
}

sub get_text_width
{
	my $s = shift // '';
	my $width = 0;
	for (my $i = 0; $i < length($s);) {
		my ($byte_count, $w) = get_character_width($s, $i);
		$i += $byte_count;
		$width += $w;
	}
	return $width;
}

sub trim_text_at_width
{
	my ($s, $expected_width, $append_suffix) = @_;
	my $width_upper_limit = $expected_width - get_text_width($append_suffix);
	my ($i, $width) = (0, 0);
	for (; $i < length($s);) {
		my ($byte_count, $w) = get_character_width($s, $i);
		last if $width + $byte_count > $width_upper_limit;
		$i += $byte_count;
		$width += $w;
	}
	return substr($s, 0, $i) . $append_suffix . (" " x ($width_upper_limit - $width));
}

sub quantile
{
	my ($data, $prob) = @_;
	my $index = (scalar(@{$data}) + 1) * $prob - 1;
	my $base_value = $data->[int($index)];
	return $base_value + ($data->[int($index) + 1] - $base_value) * ($index - int($index));
}

sub mean
{
	my $data = shift @_;
	if (scalar(@{$data}) == 0) {
		return "NA";
	} else {
		my $sum = 0;
		for my $value (@{$data}) {
			$sum += $value;
		}
		return $sum / scalar(@{$data});
	}
}

sub calc_summary
{
	my ($data, $name, $summary_fields) = @_;
	my @values = sort { $a <=> $b } map { $_->{$name} } @{$data};
	return {
		$summary_fields->[0] => $values[0],              # "Min."
		$summary_fields->[1] => quantile(\@values, .25), # "1st Qu."
		$summary_fields->[2] => quantile(\@values, .5),  # "Median"
		$summary_fields->[3] => mean(\@values),          # "Mean"
		$summary_fields->[4] => quantile(\@values, .75), # "3rd Qu."
		$summary_fields->[5] => $values[$#values],       # "Max."
	};
}

sub do_tsv_summary
{
	my $in_file;
	if (scalar(@ARGV) >= 1) {
		$in_file = shift @ARGV;
	} elsif (not -t STDIN) {
		$in_file = $STDIN;
	} else {
		print "Usage: $cmd_prefix$cmd <in.txt>\n";
		exit 1;
	}
	my $d = load_tsv($in_file);
	my %results = ();
	my @summary_fields = ("Min.", "1st Qu.", "Median", "Mean", "3rd Qu.", "Max.");
	for my $name (df_get_names($d)) {
		$results{$name} = calc_summary($d->{data}, $name, \@summary_fields);
	}
	my $summary = {
		names => [ "stat_name", df_get_names($d) ],
		data => [ ]
	};
	for my $stat_name (@summary_fields) {
		my %item = ( stat_name => $stat_name );
		for my $name (df_get_names($d)) {
			$item{$name} = $results{$name}->{$stat_name};
		}
		push @{$summary->{data}}, \%item;
	}
	write_tsv($summary);
	exit 0;
}

sub do_install
{
	my $dir = dirname($0);
	for my $cmd (sort keys %{$dispatcher}) {
		my $name = $dir . $APPNAME . '-' . $cmd;
		unless (-e $name) {
			symlink $APPNAME, $name or die "Error: Can not create symbolic link '$name'!";
			print STDERR "Symbolic link '$name' created.\n";
		}
	}
	print STDERR "All symbolic links are created.\n";
	eval("use Excel::Writer::XLSX");
	print STDERR "Warning: Perl module 'Excel::Writer::XLSX' is required for writing Excel files\n" if $@;
	eval("use Spreadsheet::XLSX");
	print STDERR "Warning: Perl module 'Spreadsheet::XLSX' is required for reading Excel files\n" if $@;
	exit 0;
}

sub do_test
{
	my ($total, $ok, $failed) = (0, 0, 0);
	chdir(dirname($0));
	foreach my $script (glob("test/*.sh")) {
		print STDERR "$script\n";
		open my $fh, "-|", $script or die "Error: Can not execute script '$script'!";
		while (my $line = <$fh>) {
			if ($line =~ /^OK/) {
				$total++;
				$ok++;
			} elsif ($line =~ /^Failed/) {
				$total++;
				$failed++;
			}
			print ". $line" if $verbose;
		}
		close $fh;
	}
	print STDERR "Total $total test(s), $ok passed and $failed failed.\n";
	exit 0;
}
